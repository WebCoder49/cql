// Code generated from Cql.g4 by ANTLR 4.13.1. DO NOT EDIT.

package cql // Cql
import (
	"fmt"
	"strconv"
  	"sync"

	"github.com/antlr4-go/antlr/v4"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = strconv.Itoa
var _ = sync.Once{}


type CqlParser struct {
	*antlr.BaseParser
}

var CqlParserStaticData struct {
  once                   sync.Once
  serializedATN          []int32
  LiteralNames           []string
  SymbolicNames          []string
  RuleNames              []string
  PredictionContextCache *antlr.PredictionContextCache
  atn                    *antlr.ATN
  decisionToDFA          []*antlr.DFA
}

func cqlParserInit() {
  staticData := &CqlParserStaticData
  staticData.LiteralNames = []string{
    "", "'library'", "'version'", "'using'", "'called'", "'include'", "'public'", 
    "'private'", "'parameter'", "'default'", "'codesystem'", "':'", "'valueset'", 
    "'codesystems'", "'{'", "','", "'}'", "'.'", "'code'", "'from'", "'concept'", 
    "'List'", "'<'", "'>'", "'Interval'", "'Tuple'", "'Choice'", "'define'", 
    "'context'", "'fluent'", "'function'", "'('", "')'", "'returns'", "'external'", 
    "'with'", "'such that'", "'without'", "'['", "'->'", "']'", "'in'", 
    "'='", "'~'", "'let'", "'where'", "'return'", "'all'", "'distinct'", 
    "'aggregate'", "'starting'", "'sort'", "'by'", "'asc'", "'ascending'", 
    "'desc'", "'descending'", "'is'", "'not'", "'null'", "'true'", "'false'", 
    "'as'", "'cast'", "'exists'", "'properly'", "'between'", "'and'", "'duration'", 
    "'difference'", "'<='", "'>='", "'!='", "'!~'", "'contains'", "'or'", 
    "'xor'", "'implies'", "'|'", "'union'", "'intersect'", "'except'", "'year'", 
    "'month'", "'week'", "'day'", "'hour'", "'minute'", "'second'", "'millisecond'", 
    "'date'", "'time'", "'timezone'", "'timezoneoffset'", "'years'", "'months'", 
    "'weeks'", "'days'", "'hours'", "'minutes'", "'seconds'", "'milliseconds'", 
    "'convert'", "'to'", "'+'", "'-'", "'start'", "'end'", "'of'", "'width'", 
    "'successor'", "'predecessor'", "'singleton'", "'point'", "'minimum'", 
    "'maximum'", "'^'", "'*'", "'/'", "'div'", "'mod'", "'&'", "'if'", "'then'", 
    "'else'", "'case'", "'flatten'", "'expand'", "'collapse'", "'per'", 
    "'when'", "'or before'", "'or after'", "'or more'", "'or less'", "'less than'", 
    "'more than'", "'on or'", "'before'", "'after'", "'or on'", "'starts'", 
    "'ends'", "'occurs'", "'same'", "'includes'", "'during'", "'included in'", 
    "'within'", "'meets'", "'overlaps'", "'$this'", "'$index'", "'$total'", 
    "'display'", "'Code'", "'Concept'", "'%'",
  }
  staticData.SymbolicNames = []string{
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", 
    "", "", "", "", "", "QUOTEDIDENTIFIER", "DATETIME", "LONGNUMBER", "DATE", 
    "TIME", "IDENTIFIER", "DELIMITEDIDENTIFIER", "STRING", "NUMBER", "WS", 
    "COMMENT", "LINE_COMMENT",
  }
  staticData.RuleNames = []string{
    "definition", "library", "libraryDefinition", "usingDefinition", "includeDefinition", 
    "localIdentifier", "accessModifier", "parameterDefinition", "codesystemDefinition", 
    "valuesetDefinition", "codesystems", "codesystemIdentifier", "libraryIdentifier", 
    "codeDefinition", "conceptDefinition", "codeIdentifier", "codesystemId", 
    "valuesetId", "versionSpecifier", "codeId", "typeSpecifier", "namedTypeSpecifier", 
    "modelIdentifier", "listTypeSpecifier", "intervalTypeSpecifier", "tupleTypeSpecifier", 
    "tupleElementDefinition", "choiceTypeSpecifier", "statement", "expressionDefinition", 
    "contextDefinition", "fluentModifier", "functionDefinition", "operandDefinition", 
    "functionBody", "querySource", "aliasedQuerySource", "alias", "queryInclusionClause", 
    "withClause", "withoutClause", "retrieve", "contextIdentifier", "codePath", 
    "codeComparator", "terminology", "qualifier", "query", "sourceClause", 
    "letClause", "letClauseItem", "whereClause", "returnClause", "aggregateClause", 
    "startingClause", "sortClause", "sortDirection", "sortByItem", "qualifiedIdentifier", 
    "qualifiedIdentifierExpression", "qualifierExpression", "simplePath", 
    "simpleLiteral", "expression", "dateTimePrecision", "dateTimeComponent", 
    "pluralDateTimePrecision", "expressionTerm", "caseExpressionItem", "dateTimePrecisionSpecifier", 
    "relativeQualifier", "offsetRelativeQualifier", "exclusiveRelativeQualifier", 
    "quantityOffset", "temporalRelationship", "intervalOperatorPhrase", 
    "term", "qualifiedInvocation", "qualifiedFunction", "invocation", "function", 
    "ratio", "literal", "intervalSelector", "tupleSelector", "tupleElementSelector", 
    "instanceSelector", "instanceElementSelector", "listSelector", "displayClause", 
    "codeSelector", "conceptSelector", "keyword", "reservedWord", "keywordIdentifier", 
    "obsoleteIdentifier", "functionIdentifier", "typeNameIdentifier", "referentialIdentifier", 
    "referentialOrTypeNameIdentifier", "identifierOrFunctionIdentifier", 
    "identifier", "externalConstant", "paramList", "quantity", "unit",
  }
  staticData.PredictionContextCache = antlr.NewPredictionContextCache()
  staticData.serializedATN = []int32{
	4, 1, 169, 1188, 2, 0, 7, 0, 2, 1, 7, 1, 2, 2, 7, 2, 2, 3, 7, 3, 2, 4, 
	7, 4, 2, 5, 7, 5, 2, 6, 7, 6, 2, 7, 7, 7, 2, 8, 7, 8, 2, 9, 7, 9, 2, 10, 
	7, 10, 2, 11, 7, 11, 2, 12, 7, 12, 2, 13, 7, 13, 2, 14, 7, 14, 2, 15, 7, 
	15, 2, 16, 7, 16, 2, 17, 7, 17, 2, 18, 7, 18, 2, 19, 7, 19, 2, 20, 7, 20, 
	2, 21, 7, 21, 2, 22, 7, 22, 2, 23, 7, 23, 2, 24, 7, 24, 2, 25, 7, 25, 2, 
	26, 7, 26, 2, 27, 7, 27, 2, 28, 7, 28, 2, 29, 7, 29, 2, 30, 7, 30, 2, 31, 
	7, 31, 2, 32, 7, 32, 2, 33, 7, 33, 2, 34, 7, 34, 2, 35, 7, 35, 2, 36, 7, 
	36, 2, 37, 7, 37, 2, 38, 7, 38, 2, 39, 7, 39, 2, 40, 7, 40, 2, 41, 7, 41, 
	2, 42, 7, 42, 2, 43, 7, 43, 2, 44, 7, 44, 2, 45, 7, 45, 2, 46, 7, 46, 2, 
	47, 7, 47, 2, 48, 7, 48, 2, 49, 7, 49, 2, 50, 7, 50, 2, 51, 7, 51, 2, 52, 
	7, 52, 2, 53, 7, 53, 2, 54, 7, 54, 2, 55, 7, 55, 2, 56, 7, 56, 2, 57, 7, 
	57, 2, 58, 7, 58, 2, 59, 7, 59, 2, 60, 7, 60, 2, 61, 7, 61, 2, 62, 7, 62, 
	2, 63, 7, 63, 2, 64, 7, 64, 2, 65, 7, 65, 2, 66, 7, 66, 2, 67, 7, 67, 2, 
	68, 7, 68, 2, 69, 7, 69, 2, 70, 7, 70, 2, 71, 7, 71, 2, 72, 7, 72, 2, 73, 
	7, 73, 2, 74, 7, 74, 2, 75, 7, 75, 2, 76, 7, 76, 2, 77, 7, 77, 2, 78, 7, 
	78, 2, 79, 7, 79, 2, 80, 7, 80, 2, 81, 7, 81, 2, 82, 7, 82, 2, 83, 7, 83, 
	2, 84, 7, 84, 2, 85, 7, 85, 2, 86, 7, 86, 2, 87, 7, 87, 2, 88, 7, 88, 2, 
	89, 7, 89, 2, 90, 7, 90, 2, 91, 7, 91, 2, 92, 7, 92, 2, 93, 7, 93, 2, 94, 
	7, 94, 2, 95, 7, 95, 2, 96, 7, 96, 2, 97, 7, 97, 2, 98, 7, 98, 2, 99, 7, 
	99, 2, 100, 7, 100, 2, 101, 7, 101, 2, 102, 7, 102, 2, 103, 7, 103, 2, 
	104, 7, 104, 2, 105, 7, 105, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 
	3, 0, 220, 8, 0, 1, 1, 3, 1, 223, 8, 1, 1, 1, 5, 1, 226, 8, 1, 10, 1, 12, 
	1, 229, 9, 1, 1, 1, 5, 1, 232, 8, 1, 10, 1, 12, 1, 235, 9, 1, 1, 1, 1, 
	1, 1, 2, 1, 2, 1, 2, 1, 2, 3, 2, 243, 8, 2, 1, 3, 1, 3, 1, 3, 1, 3, 3, 
	3, 249, 8, 3, 1, 3, 1, 3, 3, 3, 253, 8, 3, 1, 4, 1, 4, 1, 4, 1, 4, 3, 4, 
	259, 8, 4, 1, 4, 1, 4, 3, 4, 263, 8, 4, 1, 5, 1, 5, 1, 6, 1, 6, 1, 7, 3, 
	7, 270, 8, 7, 1, 7, 1, 7, 1, 7, 3, 7, 275, 8, 7, 1, 7, 1, 7, 3, 7, 279, 
	8, 7, 1, 8, 3, 8, 282, 8, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 1, 8, 3, 8, 
	290, 8, 8, 1, 9, 3, 9, 293, 8, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 1, 9, 3, 
	9, 301, 8, 9, 1, 9, 3, 9, 304, 8, 9, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 
	5, 10, 311, 8, 10, 10, 10, 12, 10, 314, 9, 10, 1, 10, 1, 10, 1, 11, 1, 
	11, 1, 11, 3, 11, 321, 8, 11, 1, 11, 1, 11, 1, 12, 1, 12, 1, 13, 3, 13, 
	328, 8, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 1, 13, 3, 13, 337, 
	8, 13, 1, 14, 3, 14, 340, 8, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 14, 1, 
	14, 1, 14, 5, 14, 349, 8, 14, 10, 14, 12, 14, 352, 9, 14, 1, 14, 1, 14, 
	3, 14, 356, 8, 14, 1, 15, 1, 15, 1, 15, 3, 15, 361, 8, 15, 1, 15, 1, 15, 
	1, 16, 1, 16, 1, 17, 1, 17, 1, 18, 1, 18, 1, 19, 1, 19, 1, 20, 1, 20, 1, 
	20, 1, 20, 1, 20, 3, 20, 378, 8, 20, 1, 21, 1, 21, 1, 21, 5, 21, 383, 8, 
	21, 10, 21, 12, 21, 386, 9, 21, 1, 21, 1, 21, 1, 22, 1, 22, 1, 23, 1, 23, 
	1, 23, 1, 23, 1, 23, 1, 24, 1, 24, 1, 24, 1, 24, 1, 24, 1, 25, 1, 25, 1, 
	25, 1, 25, 1, 25, 5, 25, 407, 8, 25, 10, 25, 12, 25, 410, 9, 25, 1, 25, 
	1, 25, 1, 26, 1, 26, 1, 26, 1, 27, 1, 27, 1, 27, 1, 27, 1, 27, 5, 27, 422, 
	8, 27, 10, 27, 12, 27, 425, 9, 27, 1, 27, 1, 27, 1, 28, 1, 28, 1, 28, 3, 
	28, 432, 8, 28, 1, 29, 1, 29, 3, 29, 436, 8, 29, 1, 29, 1, 29, 1, 29, 1, 
	29, 1, 30, 1, 30, 1, 30, 1, 30, 3, 30, 446, 8, 30, 1, 30, 1, 30, 1, 31, 
	1, 31, 1, 32, 1, 32, 3, 32, 454, 8, 32, 1, 32, 3, 32, 457, 8, 32, 1, 32, 
	1, 32, 1, 32, 1, 32, 1, 32, 1, 32, 5, 32, 465, 8, 32, 10, 32, 12, 32, 468, 
	9, 32, 3, 32, 470, 8, 32, 1, 32, 1, 32, 1, 32, 3, 32, 475, 8, 32, 1, 32, 
	1, 32, 1, 32, 3, 32, 480, 8, 32, 1, 33, 1, 33, 1, 33, 1, 34, 1, 34, 1, 
	35, 1, 35, 1, 35, 1, 35, 1, 35, 1, 35, 3, 35, 493, 8, 35, 1, 36, 1, 36, 
	1, 36, 1, 37, 1, 37, 1, 38, 1, 38, 3, 38, 502, 8, 38, 1, 39, 1, 39, 1, 
	39, 1, 39, 1, 39, 1, 40, 1, 40, 1, 40, 1, 40, 1, 40, 1, 41, 1, 41, 1, 41, 
	1, 41, 3, 41, 518, 8, 41, 1, 41, 1, 41, 1, 41, 1, 41, 1, 41, 3, 41, 525, 
	8, 41, 1, 41, 3, 41, 528, 8, 41, 1, 41, 1, 41, 1, 42, 1, 42, 1, 43, 1, 
	43, 1, 44, 1, 44, 1, 45, 1, 45, 3, 45, 540, 8, 45, 1, 46, 1, 46, 1, 47, 
	1, 47, 3, 47, 546, 8, 47, 1, 47, 5, 47, 549, 8, 47, 10, 47, 12, 47, 552, 
	9, 47, 1, 47, 3, 47, 555, 8, 47, 1, 47, 1, 47, 3, 47, 559, 8, 47, 1, 47, 
	3, 47, 562, 8, 47, 1, 48, 3, 48, 565, 8, 48, 1, 48, 1, 48, 1, 48, 5, 48, 
	570, 8, 48, 10, 48, 12, 48, 573, 9, 48, 1, 49, 1, 49, 1, 49, 1, 49, 5, 
	49, 579, 8, 49, 10, 49, 12, 49, 582, 9, 49, 1, 50, 1, 50, 1, 50, 1, 50, 
	1, 51, 1, 51, 1, 51, 1, 52, 1, 52, 3, 52, 593, 8, 52, 1, 52, 1, 52, 1, 
	53, 1, 53, 3, 53, 599, 8, 53, 1, 53, 1, 53, 3, 53, 603, 8, 53, 1, 53, 1, 
	53, 1, 53, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 1, 54, 3, 54, 615, 
	8, 54, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 1, 55, 5, 55, 623, 8, 55, 10, 
	55, 12, 55, 626, 9, 55, 3, 55, 628, 8, 55, 1, 56, 1, 56, 1, 57, 1, 57, 
	3, 57, 634, 8, 57, 1, 58, 1, 58, 1, 58, 5, 58, 639, 8, 58, 10, 58, 12, 
	58, 642, 9, 58, 1, 58, 1, 58, 1, 59, 1, 59, 1, 59, 5, 59, 649, 8, 59, 10, 
	59, 12, 59, 652, 9, 59, 1, 59, 1, 59, 1, 60, 1, 60, 1, 61, 1, 61, 1, 61, 
	1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 1, 61, 5, 61, 669, 8, 
	61, 10, 61, 12, 61, 672, 9, 61, 1, 62, 1, 62, 3, 62, 676, 8, 62, 1, 63, 
	1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 
	63, 1, 63, 1, 63, 1, 63, 3, 63, 693, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 
	1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 
	63, 709, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 
	1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 3, 63, 724, 8, 63, 1, 63, 1, 63, 1, 
	63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 
	1, 63, 1, 63, 1, 63, 3, 63, 742, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 
	63, 1, 63, 3, 63, 750, 8, 63, 1, 63, 1, 63, 1, 63, 1, 63, 1, 63, 5, 63, 
	757, 8, 63, 10, 63, 12, 63, 760, 9, 63, 1, 64, 1, 64, 1, 65, 1, 65, 1, 
	65, 1, 65, 1, 65, 3, 65, 769, 8, 65, 1, 66, 1, 66, 1, 67, 1, 67, 1, 67, 
	1, 67, 1, 67, 1, 67, 1, 67, 3, 67, 780, 8, 67, 1, 67, 1, 67, 1, 67, 1, 
	67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 
	1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 
	67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 
	1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 
	67, 1, 67, 3, 67, 829, 8, 67, 1, 67, 4, 67, 832, 8, 67, 11, 67, 12, 67, 
	833, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 
	67, 1, 67, 3, 67, 847, 8, 67, 3, 67, 849, 8, 67, 3, 67, 851, 8, 67, 1, 
	67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 
	1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 1, 67, 5, 67, 870, 8, 67, 10, 67, 12, 
	67, 873, 9, 67, 1, 68, 1, 68, 1, 68, 1, 68, 1, 68, 1, 69, 1, 69, 1, 69, 
	1, 70, 1, 70, 1, 71, 1, 71, 1, 72, 1, 72, 1, 73, 1, 73, 3, 73, 891, 8, 
	73, 1, 73, 1, 73, 1, 73, 3, 73, 896, 8, 73, 1, 74, 3, 74, 899, 8, 74, 1, 
	74, 1, 74, 1, 74, 3, 74, 904, 8, 74, 3, 74, 906, 8, 74, 1, 75, 3, 75, 909, 
	8, 75, 1, 75, 1, 75, 3, 75, 913, 8, 75, 1, 75, 1, 75, 3, 75, 917, 8, 75, 
	1, 75, 3, 75, 920, 8, 75, 1, 75, 3, 75, 923, 8, 75, 1, 75, 1, 75, 3, 75, 
	927, 8, 75, 1, 75, 3, 75, 930, 8, 75, 1, 75, 3, 75, 933, 8, 75, 1, 75, 
	3, 75, 936, 8, 75, 1, 75, 1, 75, 3, 75, 940, 8, 75, 1, 75, 3, 75, 943, 
	8, 75, 1, 75, 3, 75, 946, 8, 75, 1, 75, 1, 75, 3, 75, 950, 8, 75, 1, 75, 
	3, 75, 953, 8, 75, 1, 75, 3, 75, 956, 8, 75, 1, 75, 3, 75, 959, 8, 75, 
	1, 75, 1, 75, 1, 75, 1, 75, 3, 75, 965, 8, 75, 1, 75, 1, 75, 3, 75, 969, 
	8, 75, 1, 75, 3, 75, 972, 8, 75, 1, 75, 1, 75, 3, 75, 976, 8, 75, 1, 75, 
	3, 75, 979, 8, 75, 1, 75, 1, 75, 3, 75, 983, 8, 75, 1, 75, 1, 75, 3, 75, 
	987, 8, 75, 3, 75, 989, 8, 75, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 
	1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 1, 76, 3, 76, 1004, 8, 76, 1, 
	77, 1, 77, 3, 77, 1008, 8, 77, 1, 78, 1, 78, 1, 78, 3, 78, 1013, 8, 78, 
	1, 78, 1, 78, 1, 79, 1, 79, 1, 79, 1, 79, 1, 79, 3, 79, 1022, 8, 79, 1, 
	80, 1, 80, 1, 80, 3, 80, 1027, 8, 80, 1, 80, 1, 80, 1, 81, 1, 81, 1, 81, 
	1, 81, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 82, 1, 
	82, 3, 82, 1045, 8, 82, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 1, 83, 
	1, 84, 3, 84, 1055, 8, 84, 1, 84, 1, 84, 1, 84, 1, 84, 1, 84, 5, 84, 1062, 
	8, 84, 10, 84, 12, 84, 1065, 9, 84, 3, 84, 1067, 8, 84, 1, 84, 1, 84, 1, 
	85, 1, 85, 1, 85, 1, 85, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 1, 86, 5, 86, 
	1081, 8, 86, 10, 86, 12, 86, 1084, 9, 86, 3, 86, 1086, 8, 86, 1, 86, 1, 
	86, 1, 87, 1, 87, 1, 87, 1, 87, 1, 88, 1, 88, 1, 88, 1, 88, 1, 88, 3, 88, 
	1099, 8, 88, 3, 88, 1101, 8, 88, 1, 88, 1, 88, 1, 88, 1, 88, 5, 88, 1107, 
	8, 88, 10, 88, 12, 88, 1110, 9, 88, 3, 88, 1112, 8, 88, 1, 88, 1, 88, 1, 
	89, 1, 89, 1, 89, 1, 90, 1, 90, 1, 90, 1, 90, 1, 90, 3, 90, 1124, 8, 90, 
	1, 91, 1, 91, 1, 91, 1, 91, 1, 91, 5, 91, 1131, 8, 91, 10, 91, 12, 91, 
	1134, 9, 91, 1, 91, 1, 91, 3, 91, 1138, 8, 91, 1, 92, 1, 92, 1, 93, 1, 
	93, 1, 94, 1, 94, 1, 95, 1, 95, 1, 96, 1, 96, 1, 97, 1, 97, 1, 98, 1, 98, 
	3, 98, 1154, 8, 98, 1, 99, 1, 99, 3, 99, 1158, 8, 99, 1, 100, 1, 100, 3, 
	100, 1162, 8, 100, 1, 101, 1, 101, 1, 102, 1, 102, 1, 102, 3, 102, 1169, 
	8, 102, 1, 103, 1, 103, 1, 103, 5, 103, 1174, 8, 103, 10, 103, 12, 103, 
	1177, 9, 103, 1, 104, 1, 104, 3, 104, 1181, 8, 104, 1, 105, 1, 105, 1, 
	105, 3, 105, 1186, 8, 105, 1, 105, 0, 3, 122, 126, 134, 106, 0, 2, 4, 6, 
	8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38, 40, 42, 
	44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74, 76, 78, 
	80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108, 110, 112, 
	114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138, 140, 142, 
	144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168, 170, 172, 
	174, 176, 178, 180, 182, 184, 186, 188, 190, 192, 194, 196, 198, 200, 202, 
	204, 206, 208, 210, 0, 36, 1, 0, 6, 7, 1, 0, 41, 43, 1, 0, 47, 48, 1, 0, 
	53, 56, 2, 0, 22, 23, 70, 71, 2, 0, 42, 43, 72, 73, 2, 0, 41, 41, 74, 74, 
	1, 0, 75, 76, 1, 0, 78, 81, 1, 0, 59, 61, 2, 0, 57, 57, 62, 62, 1, 0, 82, 
	89, 1, 0, 94, 101, 1, 0, 104, 105, 1, 0, 106, 107, 1, 0, 114, 115, 2, 0, 
	48, 48, 126, 126, 1, 0, 127, 128, 1, 0, 117, 120, 2, 0, 104, 105, 121, 
	121, 1, 0, 131, 132, 1, 0, 133, 134, 1, 0, 135, 136, 1, 0, 138, 139, 1, 
	0, 141, 143, 1, 0, 146, 147, 1, 0, 60, 61, 2, 0, 31, 31, 38, 38, 2, 0, 
	32, 32, 40, 40, 15, 0, 1, 10, 12, 13, 18, 21, 24, 25, 27, 30, 35, 37, 41, 
	41, 44, 69, 74, 77, 79, 103, 106, 115, 119, 120, 122, 134, 137, 150, 154, 
	156, 19, 0, 19, 19, 21, 21, 24, 25, 35, 37, 41, 41, 44, 44, 46, 49, 51, 
	51, 57, 69, 75, 75, 82, 89, 94, 103, 108, 108, 112, 115, 122, 130, 137, 
	140, 143, 144, 146, 148, 155, 156, 20, 0, 1, 10, 12, 13, 18, 18, 20, 20, 
	27, 30, 45, 45, 50, 50, 52, 56, 74, 74, 76, 77, 79, 81, 90, 93, 106, 107, 
	109, 111, 119, 120, 131, 134, 141, 142, 145, 145, 149, 150, 154, 154, 11, 
	0, 2, 2, 18, 18, 20, 20, 45, 45, 47, 48, 58, 58, 64, 64, 74, 74, 90, 93, 
	106, 107, 154, 156, 16, 0, 1, 10, 12, 13, 18, 21, 24, 25, 27, 30, 35, 37, 
	41, 41, 44, 69, 74, 77, 79, 103, 106, 115, 119, 120, 122, 134, 138, 139, 
	141, 150, 154, 156, 2, 0, 90, 91, 155, 156, 2, 0, 158, 158, 163, 164, 1290, 
	0, 219, 1, 0, 0, 0, 2, 222, 1, 0, 0, 0, 4, 238, 1, 0, 0, 0, 6, 244, 1, 
	0, 0, 0, 8, 254, 1, 0, 0, 0, 10, 264, 1, 0, 0, 0, 12, 266, 1, 0, 0, 0, 
	14, 269, 1, 0, 0, 0, 16, 281, 1, 0, 0, 0, 18, 292, 1, 0, 0, 0, 20, 305, 
	1, 0, 0, 0, 22, 320, 1, 0, 0, 0, 24, 324, 1, 0, 0, 0, 26, 327, 1, 0, 0, 
	0, 28, 339, 1, 0, 0, 0, 30, 360, 1, 0, 0, 0, 32, 364, 1, 0, 0, 0, 34, 366, 
	1, 0, 0, 0, 36, 368, 1, 0, 0, 0, 38, 370, 1, 0, 0, 0, 40, 377, 1, 0, 0, 
	0, 42, 384, 1, 0, 0, 0, 44, 389, 1, 0, 0, 0, 46, 391, 1, 0, 0, 0, 48, 396, 
	1, 0, 0, 0, 50, 401, 1, 0, 0, 0, 52, 413, 1, 0, 0, 0, 54, 416, 1, 0, 0, 
	0, 56, 431, 1, 0, 0, 0, 58, 433, 1, 0, 0, 0, 60, 441, 1, 0, 0, 0, 62, 449, 
	1, 0, 0, 0, 64, 451, 1, 0, 0, 0, 66, 481, 1, 0, 0, 0, 68, 484, 1, 0, 0, 
	0, 70, 492, 1, 0, 0, 0, 72, 494, 1, 0, 0, 0, 74, 497, 1, 0, 0, 0, 76, 501, 
	1, 0, 0, 0, 78, 503, 1, 0, 0, 0, 80, 508, 1, 0, 0, 0, 82, 513, 1, 0, 0, 
	0, 84, 531, 1, 0, 0, 0, 86, 533, 1, 0, 0, 0, 88, 535, 1, 0, 0, 0, 90, 539, 
	1, 0, 0, 0, 92, 541, 1, 0, 0, 0, 94, 543, 1, 0, 0, 0, 96, 564, 1, 0, 0, 
	0, 98, 574, 1, 0, 0, 0, 100, 583, 1, 0, 0, 0, 102, 587, 1, 0, 0, 0, 104, 
	590, 1, 0, 0, 0, 106, 596, 1, 0, 0, 0, 108, 607, 1, 0, 0, 0, 110, 616, 
	1, 0, 0, 0, 112, 629, 1, 0, 0, 0, 114, 631, 1, 0, 0, 0, 116, 640, 1, 0, 
	0, 0, 118, 650, 1, 0, 0, 0, 120, 655, 1, 0, 0, 0, 122, 657, 1, 0, 0, 0, 
	124, 675, 1, 0, 0, 0, 126, 708, 1, 0, 0, 0, 128, 761, 1, 0, 0, 0, 130, 
	768, 1, 0, 0, 0, 132, 770, 1, 0, 0, 0, 134, 850, 1, 0, 0, 0, 136, 874, 
	1, 0, 0, 0, 138, 879, 1, 0, 0, 0, 140, 882, 1, 0, 0, 0, 142, 884, 1, 0, 
	0, 0, 144, 886, 1, 0, 0, 0, 146, 895, 1, 0, 0, 0, 148, 905, 1, 0, 0, 0, 
	150, 988, 1, 0, 0, 0, 152, 1003, 1, 0, 0, 0, 154, 1007, 1, 0, 0, 0, 156, 
	1009, 1, 0, 0, 0, 158, 1021, 1, 0, 0, 0, 160, 1023, 1, 0, 0, 0, 162, 1030, 
	1, 0, 0, 0, 164, 1044, 1, 0, 0, 0, 166, 1046, 1, 0, 0, 0, 168, 1054, 1, 
	0, 0, 0, 170, 1070, 1, 0, 0, 0, 172, 1074, 1, 0, 0, 0, 174, 1089, 1, 0, 
	0, 0, 176, 1100, 1, 0, 0, 0, 178, 1115, 1, 0, 0, 0, 180, 1118, 1, 0, 0, 
	0, 182, 1125, 1, 0, 0, 0, 184, 1139, 1, 0, 0, 0, 186, 1141, 1, 0, 0, 0, 
	188, 1143, 1, 0, 0, 0, 190, 1145, 1, 0, 0, 0, 192, 1147, 1, 0, 0, 0, 194, 
	1149, 1, 0, 0, 0, 196, 1153, 1, 0, 0, 0, 198, 1157, 1, 0, 0, 0, 200, 1161, 
	1, 0, 0, 0, 202, 1163, 1, 0, 0, 0, 204, 1165, 1, 0, 0, 0, 206, 1170, 1, 
	0, 0, 0, 208, 1178, 1, 0, 0, 0, 210, 1185, 1, 0, 0, 0, 212, 220, 3, 6, 
	3, 0, 213, 220, 3, 8, 4, 0, 214, 220, 3, 16, 8, 0, 215, 220, 3, 18, 9, 
	0, 216, 220, 3, 26, 13, 0, 217, 220, 3, 28, 14, 0, 218, 220, 3, 14, 7, 
	0, 219, 212, 1, 0, 0, 0, 219, 213, 1, 0, 0, 0, 219, 214, 1, 0, 0, 0, 219, 
	215, 1, 0, 0, 0, 219, 216, 1, 0, 0, 0, 219, 217, 1, 0, 0, 0, 219, 218, 
	1, 0, 0, 0, 220, 1, 1, 0, 0, 0, 221, 223, 3, 4, 2, 0, 222, 221, 1, 0, 0, 
	0, 222, 223, 1, 0, 0, 0, 223, 227, 1, 0, 0, 0, 224, 226, 3, 0, 0, 0, 225, 
	224, 1, 0, 0, 0, 226, 229, 1, 0, 0, 0, 227, 225, 1, 0, 0, 0, 227, 228, 
	1, 0, 0, 0, 228, 233, 1, 0, 0, 0, 229, 227, 1, 0, 0, 0, 230, 232, 3, 56, 
	28, 0, 231, 230, 1, 0, 0, 0, 232, 235, 1, 0, 0, 0, 233, 231, 1, 0, 0, 0, 
	233, 234, 1, 0, 0, 0, 234, 236, 1, 0, 0, 0, 235, 233, 1, 0, 0, 0, 236, 
	237, 5, 0, 0, 1, 237, 3, 1, 0, 0, 0, 238, 239, 5, 1, 0, 0, 239, 242, 3, 
	116, 58, 0, 240, 241, 5, 2, 0, 0, 241, 243, 3, 36, 18, 0, 242, 240, 1, 
	0, 0, 0, 242, 243, 1, 0, 0, 0, 243, 5, 1, 0, 0, 0, 244, 245, 5, 3, 0, 0, 
	245, 248, 3, 116, 58, 0, 246, 247, 5, 2, 0, 0, 247, 249, 3, 36, 18, 0, 
	248, 246, 1, 0, 0, 0, 248, 249, 1, 0, 0, 0, 249, 252, 1, 0, 0, 0, 250, 
	251, 5, 4, 0, 0, 251, 253, 3, 10, 5, 0, 252, 250, 1, 0, 0, 0, 252, 253, 
	1, 0, 0, 0, 253, 7, 1, 0, 0, 0, 254, 255, 5, 5, 0, 0, 255, 258, 3, 116, 
	58, 0, 256, 257, 5, 2, 0, 0, 257, 259, 3, 36, 18, 0, 258, 256, 1, 0, 0, 
	0, 258, 259, 1, 0, 0, 0, 259, 262, 1, 0, 0, 0, 260, 261, 5, 4, 0, 0, 261, 
	263, 3, 10, 5, 0, 262, 260, 1, 0, 0, 0, 262, 263, 1, 0, 0, 0, 263, 9, 1, 
	0, 0, 0, 264, 265, 3, 202, 101, 0, 265, 11, 1, 0, 0, 0, 266, 267, 7, 0, 
	0, 0, 267, 13, 1, 0, 0, 0, 268, 270, 3, 12, 6, 0, 269, 268, 1, 0, 0, 0, 
	269, 270, 1, 0, 0, 0, 270, 271, 1, 0, 0, 0, 271, 272, 5, 8, 0, 0, 272, 
	274, 3, 202, 101, 0, 273, 275, 3, 40, 20, 0, 274, 273, 1, 0, 0, 0, 274, 
	275, 1, 0, 0, 0, 275, 278, 1, 0, 0, 0, 276, 277, 5, 9, 0, 0, 277, 279, 
	3, 126, 63, 0, 278, 276, 1, 0, 0, 0, 278, 279, 1, 0, 0, 0, 279, 15, 1, 
	0, 0, 0, 280, 282, 3, 12, 6, 0, 281, 280, 1, 0, 0, 0, 281, 282, 1, 0, 0, 
	0, 282, 283, 1, 0, 0, 0, 283, 284, 5, 10, 0, 0, 284, 285, 3, 202, 101, 
	0, 285, 286, 5, 11, 0, 0, 286, 289, 3, 32, 16, 0, 287, 288, 5, 2, 0, 0, 
	288, 290, 3, 36, 18, 0, 289, 287, 1, 0, 0, 0, 289, 290, 1, 0, 0, 0, 290, 
	17, 1, 0, 0, 0, 291, 293, 3, 12, 6, 0, 292, 291, 1, 0, 0, 0, 292, 293, 
	1, 0, 0, 0, 293, 294, 1, 0, 0, 0, 294, 295, 5, 12, 0, 0, 295, 296, 3, 202, 
	101, 0, 296, 297, 5, 11, 0, 0, 297, 300, 3, 34, 17, 0, 298, 299, 5, 2, 
	0, 0, 299, 301, 3, 36, 18, 0, 300, 298, 1, 0, 0, 0, 300, 301, 1, 0, 0, 
	0, 301, 303, 1, 0, 0, 0, 302, 304, 3, 20, 10, 0, 303, 302, 1, 0, 0, 0, 
	303, 304, 1, 0, 0, 0, 304, 19, 1, 0, 0, 0, 305, 306, 5, 13, 0, 0, 306, 
	307, 5, 14, 0, 0, 307, 312, 3, 22, 11, 0, 308, 309, 5, 15, 0, 0, 309, 311, 
	3, 22, 11, 0, 310, 308, 1, 0, 0, 0, 311, 314, 1, 0, 0, 0, 312, 310, 1, 
	0, 0, 0, 312, 313, 1, 0, 0, 0, 313, 315, 1, 0, 0, 0, 314, 312, 1, 0, 0, 
	0, 315, 316, 5, 16, 0, 0, 316, 21, 1, 0, 0, 0, 317, 318, 3, 24, 12, 0, 
	318, 319, 5, 17, 0, 0, 319, 321, 1, 0, 0, 0, 320, 317, 1, 0, 0, 0, 320, 
	321, 1, 0, 0, 0, 321, 322, 1, 0, 0, 0, 322, 323, 3, 202, 101, 0, 323, 23, 
	1, 0, 0, 0, 324, 325, 3, 202, 101, 0, 325, 25, 1, 0, 0, 0, 326, 328, 3, 
	12, 6, 0, 327, 326, 1, 0, 0, 0, 327, 328, 1, 0, 0, 0, 328, 329, 1, 0, 0, 
	0, 329, 330, 5, 18, 0, 0, 330, 331, 3, 202, 101, 0, 331, 332, 5, 11, 0, 
	0, 332, 333, 3, 38, 19, 0, 333, 334, 5, 19, 0, 0, 334, 336, 3, 22, 11, 
	0, 335, 337, 3, 178, 89, 0, 336, 335, 1, 0, 0, 0, 336, 337, 1, 0, 0, 0, 
	337, 27, 1, 0, 0, 0, 338, 340, 3, 12, 6, 0, 339, 338, 1, 0, 0, 0, 339, 
	340, 1, 0, 0, 0, 340, 341, 1, 0, 0, 0, 341, 342, 5, 20, 0, 0, 342, 343, 
	3, 202, 101, 0, 343, 344, 5, 11, 0, 0, 344, 345, 5, 14, 0, 0, 345, 350, 
	3, 30, 15, 0, 346, 347, 5, 15, 0, 0, 347, 349, 3, 30, 15, 0, 348, 346, 
	1, 0, 0, 0, 349, 352, 1, 0, 0, 0, 350, 348, 1, 0, 0, 0, 350, 351, 1, 0, 
	0, 0, 351, 353, 1, 0, 0, 0, 352, 350, 1, 0, 0, 0, 353, 355, 5, 16, 0, 0, 
	354, 356, 3, 178, 89, 0, 355, 354, 1, 0, 0, 0, 355, 356, 1, 0, 0, 0, 356, 
	29, 1, 0, 0, 0, 357, 358, 3, 24, 12, 0, 358, 359, 5, 17, 0, 0, 359, 361, 
	1, 0, 0, 0, 360, 357, 1, 0, 0, 0, 360, 361, 1, 0, 0, 0, 361, 362, 1, 0, 
	0, 0, 362, 363, 3, 202, 101, 0, 363, 31, 1, 0, 0, 0, 364, 365, 5, 165, 
	0, 0, 365, 33, 1, 0, 0, 0, 366, 367, 5, 165, 0, 0, 367, 35, 1, 0, 0, 0, 
	368, 369, 5, 165, 0, 0, 369, 37, 1, 0, 0, 0, 370, 371, 5, 165, 0, 0, 371, 
	39, 1, 0, 0, 0, 372, 378, 3, 42, 21, 0, 373, 378, 3, 46, 23, 0, 374, 378, 
	3, 48, 24, 0, 375, 378, 3, 50, 25, 0, 376, 378, 3, 54, 27, 0, 377, 372, 
	1, 0, 0, 0, 377, 373, 1, 0, 0, 0, 377, 374, 1, 0, 0, 0, 377, 375, 1, 0, 
	0, 0, 377, 376, 1, 0, 0, 0, 378, 41, 1, 0, 0, 0, 379, 380, 3, 92, 46, 0, 
	380, 381, 5, 17, 0, 0, 381, 383, 1, 0, 0, 0, 382, 379, 1, 0, 0, 0, 383, 
	386, 1, 0, 0, 0, 384, 382, 1, 0, 0, 0, 384, 385, 1, 0, 0, 0, 385, 387, 
	1, 0, 0, 0, 386, 384, 1, 0, 0, 0, 387, 388, 3, 198, 99, 0, 388, 43, 1, 
	0, 0, 0, 389, 390, 3, 202, 101, 0, 390, 45, 1, 0, 0, 0, 391, 392, 5, 21, 
	0, 0, 392, 393, 5, 22, 0, 0, 393, 394, 3, 40, 20, 0, 394, 395, 5, 23, 0, 
	0, 395, 47, 1, 0, 0, 0, 396, 397, 5, 24, 0, 0, 397, 398, 5, 22, 0, 0, 398, 
	399, 3, 40, 20, 0, 399, 400, 5, 23, 0, 0, 400, 49, 1, 0, 0, 0, 401, 402, 
	5, 25, 0, 0, 402, 403, 5, 14, 0, 0, 403, 408, 3, 52, 26, 0, 404, 405, 5, 
	15, 0, 0, 405, 407, 3, 52, 26, 0, 406, 404, 1, 0, 0, 0, 407, 410, 1, 0, 
	0, 0, 408, 406, 1, 0, 0, 0, 408, 409, 1, 0, 0, 0, 409, 411, 1, 0, 0, 0, 
	410, 408, 1, 0, 0, 0, 411, 412, 5, 16, 0, 0, 412, 51, 1, 0, 0, 0, 413, 
	414, 3, 196, 98, 0, 414, 415, 3, 40, 20, 0, 415, 53, 1, 0, 0, 0, 416, 417, 
	5, 26, 0, 0, 417, 418, 5, 22, 0, 0, 418, 423, 3, 40, 20, 0, 419, 420, 5, 
	15, 0, 0, 420, 422, 3, 40, 20, 0, 421, 419, 1, 0, 0, 0, 422, 425, 1, 0, 
	0, 0, 423, 421, 1, 0, 0, 0, 423, 424, 1, 0, 0, 0, 424, 426, 1, 0, 0, 0, 
	425, 423, 1, 0, 0, 0, 426, 427, 5, 23, 0, 0, 427, 55, 1, 0, 0, 0, 428, 
	432, 3, 58, 29, 0, 429, 432, 3, 60, 30, 0, 430, 432, 3, 64, 32, 0, 431, 
	428, 1, 0, 0, 0, 431, 429, 1, 0, 0, 0, 431, 430, 1, 0, 0, 0, 432, 57, 1, 
	0, 0, 0, 433, 435, 5, 27, 0, 0, 434, 436, 3, 12, 6, 0, 435, 434, 1, 0, 
	0, 0, 435, 436, 1, 0, 0, 0, 436, 437, 1, 0, 0, 0, 437, 438, 3, 202, 101, 
	0, 438, 439, 5, 11, 0, 0, 439, 440, 3, 126, 63, 0, 440, 59, 1, 0, 0, 0, 
	441, 445, 5, 28, 0, 0, 442, 443, 3, 44, 22, 0, 443, 444, 5, 17, 0, 0, 444, 
	446, 1, 0, 0, 0, 445, 442, 1, 0, 0, 0, 445, 446, 1, 0, 0, 0, 446, 447, 
	1, 0, 0, 0, 447, 448, 3, 202, 101, 0, 448, 61, 1, 0, 0, 0, 449, 450, 5, 
	29, 0, 0, 450, 63, 1, 0, 0, 0, 451, 453, 5, 27, 0, 0, 452, 454, 3, 12, 
	6, 0, 453, 452, 1, 0, 0, 0, 453, 454, 1, 0, 0, 0, 454, 456, 1, 0, 0, 0, 
	455, 457, 3, 62, 31, 0, 456, 455, 1, 0, 0, 0, 456, 457, 1, 0, 0, 0, 457, 
	458, 1, 0, 0, 0, 458, 459, 5, 30, 0, 0, 459, 460, 3, 200, 100, 0, 460, 
	469, 5, 31, 0, 0, 461, 466, 3, 66, 33, 0, 462, 463, 5, 15, 0, 0, 463, 465, 
	3, 66, 33, 0, 464, 462, 1, 0, 0, 0, 465, 468, 1, 0, 0, 0, 466, 464, 1, 
	0, 0, 0, 466, 467, 1, 0, 0, 0, 467, 470, 1, 0, 0, 0, 468, 466, 1, 0, 0, 
	0, 469, 461, 1, 0, 0, 0, 469, 470, 1, 0, 0, 0, 470, 471, 1, 0, 0, 0, 471, 
	474, 5, 32, 0, 0, 472, 473, 5, 33, 0, 0, 473, 475, 3, 40, 20, 0, 474, 472, 
	1, 0, 0, 0, 474, 475, 1, 0, 0, 0, 475, 476, 1, 0, 0, 0, 476, 479, 5, 11, 
	0, 0, 477, 480, 3, 68, 34, 0, 478, 480, 5, 34, 0, 0, 479, 477, 1, 0, 0, 
	0, 479, 478, 1, 0, 0, 0, 480, 65, 1, 0, 0, 0, 481, 482, 3, 196, 98, 0, 
	482, 483, 3, 40, 20, 0, 483, 67, 1, 0, 0, 0, 484, 485, 3, 126, 63, 0, 485, 
	69, 1, 0, 0, 0, 486, 493, 3, 82, 41, 0, 487, 493, 3, 118, 59, 0, 488, 489, 
	5, 31, 0, 0, 489, 490, 3, 126, 63, 0, 490, 491, 5, 32, 0, 0, 491, 493, 
	1, 0, 0, 0, 492, 486, 1, 0, 0, 0, 492, 487, 1, 0, 0, 0, 492, 488, 1, 0, 
	0, 0, 493, 71, 1, 0, 0, 0, 494, 495, 3, 70, 35, 0, 495, 496, 3, 74, 37, 
	0, 496, 73, 1, 0, 0, 0, 497, 498, 3, 202, 101, 0, 498, 75, 1, 0, 0, 0, 
	499, 502, 3, 78, 39, 0, 500, 502, 3, 80, 40, 0, 501, 499, 1, 0, 0, 0, 501, 
	500, 1, 0, 0, 0, 502, 77, 1, 0, 0, 0, 503, 504, 5, 35, 0, 0, 504, 505, 
	3, 72, 36, 0, 505, 506, 5, 36, 0, 0, 506, 507, 3, 126, 63, 0, 507, 79, 
	1, 0, 0, 0, 508, 509, 5, 37, 0, 0, 509, 510, 3, 72, 36, 0, 510, 511, 5, 
	36, 0, 0, 511, 512, 3, 126, 63, 0, 512, 81, 1, 0, 0, 0, 513, 517, 5, 38, 
	0, 0, 514, 515, 3, 84, 42, 0, 515, 516, 5, 39, 0, 0, 516, 518, 1, 0, 0, 
	0, 517, 514, 1, 0, 0, 0, 517, 518, 1, 0, 0, 0, 518, 519, 1, 0, 0, 0, 519, 
	527, 3, 42, 21, 0, 520, 524, 5, 11, 0, 0, 521, 522, 3, 86, 43, 0, 522, 
	523, 3, 88, 44, 0, 523, 525, 1, 0, 0, 0, 524, 521, 1, 0, 0, 0, 524, 525, 
	1, 0, 0, 0, 525, 526, 1, 0, 0, 0, 526, 528, 3, 90, 45, 0, 527, 520, 1, 
	0, 0, 0, 527, 528, 1, 0, 0, 0, 528, 529, 1, 0, 0, 0, 529, 530, 5, 40, 0, 
	0, 530, 83, 1, 0, 0, 0, 531, 532, 3, 118, 59, 0, 532, 85, 1, 0, 0, 0, 533, 
	534, 3, 122, 61, 0, 534, 87, 1, 0, 0, 0, 535, 536, 7, 1, 0, 0, 536, 89, 
	1, 0, 0, 0, 537, 540, 3, 118, 59, 0, 538, 540, 3, 126, 63, 0, 539, 537, 
	1, 0, 0, 0, 539, 538, 1, 0, 0, 0, 540, 91, 1, 0, 0, 0, 541, 542, 3, 202, 
	101, 0, 542, 93, 1, 0, 0, 0, 543, 545, 3, 96, 48, 0, 544, 546, 3, 98, 49, 
	0, 545, 544, 1, 0, 0, 0, 545, 546, 1, 0, 0, 0, 546, 550, 1, 0, 0, 0, 547, 
	549, 3, 76, 38, 0, 548, 547, 1, 0, 0, 0, 549, 552, 1, 0, 0, 0, 550, 548, 
	1, 0, 0, 0, 550, 551, 1, 0, 0, 0, 551, 554, 1, 0, 0, 0, 552, 550, 1, 0, 
	0, 0, 553, 555, 3, 102, 51, 0, 554, 553, 1, 0, 0, 0, 554, 555, 1, 0, 0, 
	0, 555, 558, 1, 0, 0, 0, 556, 559, 3, 106, 53, 0, 557, 559, 3, 104, 52, 
	0, 558, 556, 1, 0, 0, 0, 558, 557, 1, 0, 0, 0, 558, 559, 1, 0, 0, 0, 559, 
	561, 1, 0, 0, 0, 560, 562, 3, 110, 55, 0, 561, 560, 1, 0, 0, 0, 561, 562, 
	1, 0, 0, 0, 562, 95, 1, 0, 0, 0, 563, 565, 5, 19, 0, 0, 564, 563, 1, 0, 
	0, 0, 564, 565, 1, 0, 0, 0, 565, 566, 1, 0, 0, 0, 566, 571, 3, 72, 36, 
	0, 567, 568, 5, 15, 0, 0, 568, 570, 3, 72, 36, 0, 569, 567, 1, 0, 0, 0, 
	570, 573, 1, 0, 0, 0, 571, 569, 1, 0, 0, 0, 571, 572, 1, 0, 0, 0, 572, 
	97, 1, 0, 0, 0, 573, 571, 1, 0, 0, 0, 574, 575, 5, 44, 0, 0, 575, 580, 
	3, 100, 50, 0, 576, 577, 5, 15, 0, 0, 577, 579, 3, 100, 50, 0, 578, 576, 
	1, 0, 0, 0, 579, 582, 1, 0, 0, 0, 580, 578, 1, 0, 0, 0, 580, 581, 1, 0, 
	0, 0, 581, 99, 1, 0, 0, 0, 582, 580, 1, 0, 0, 0, 583, 584, 3, 202, 101, 
	0, 584, 585, 5, 11, 0, 0, 585, 586, 3, 126, 63, 0, 586, 101, 1, 0, 0, 0, 
	587, 588, 5, 45, 0, 0, 588, 589, 3, 126, 63, 0, 589, 103, 1, 0, 0, 0, 590, 
	592, 5, 46, 0, 0, 591, 593, 7, 2, 0, 0, 592, 591, 1, 0, 0, 0, 592, 593, 
	1, 0, 0, 0, 593, 594, 1, 0, 0, 0, 594, 595, 3, 126, 63, 0, 595, 105, 1, 
	0, 0, 0, 596, 598, 5, 49, 0, 0, 597, 599, 7, 2, 0, 0, 598, 597, 1, 0, 0, 
	0, 598, 599, 1, 0, 0, 0, 599, 600, 1, 0, 0, 0, 600, 602, 3, 202, 101, 0, 
	601, 603, 3, 108, 54, 0, 602, 601, 1, 0, 0, 0, 602, 603, 1, 0, 0, 0, 603, 
	604, 1, 0, 0, 0, 604, 605, 5, 11, 0, 0, 605, 606, 3, 126, 63, 0, 606, 107, 
	1, 0, 0, 0, 607, 614, 5, 50, 0, 0, 608, 615, 3, 124, 62, 0, 609, 615, 3, 
	208, 104, 0, 610, 611, 5, 31, 0, 0, 611, 612, 3, 126, 63, 0, 612, 613, 
	5, 32, 0, 0, 613, 615, 1, 0, 0, 0, 614, 608, 1, 0, 0, 0, 614, 609, 1, 0, 
	0, 0, 614, 610, 1, 0, 0, 0, 615, 109, 1, 0, 0, 0, 616, 627, 5, 51, 0, 0, 
	617, 628, 3, 112, 56, 0, 618, 619, 5, 52, 0, 0, 619, 624, 3, 114, 57, 0, 
	620, 621, 5, 15, 0, 0, 621, 623, 3, 114, 57, 0, 622, 620, 1, 0, 0, 0, 623, 
	626, 1, 0, 0, 0, 624, 622, 1, 0, 0, 0, 624, 625, 1, 0, 0, 0, 625, 628, 
	1, 0, 0, 0, 626, 624, 1, 0, 0, 0, 627, 617, 1, 0, 0, 0, 627, 618, 1, 0, 
	0, 0, 628, 111, 1, 0, 0, 0, 629, 630, 7, 3, 0, 0, 630, 113, 1, 0, 0, 0, 
	631, 633, 3, 134, 67, 0, 632, 634, 3, 112, 56, 0, 633, 632, 1, 0, 0, 0, 
	633, 634, 1, 0, 0, 0, 634, 115, 1, 0, 0, 0, 635, 636, 3, 92, 46, 0, 636, 
	637, 5, 17, 0, 0, 637, 639, 1, 0, 0, 0, 638, 635, 1, 0, 0, 0, 639, 642, 
	1, 0, 0, 0, 640, 638, 1, 0, 0, 0, 640, 641, 1, 0, 0, 0, 641, 643, 1, 0, 
	0, 0, 642, 640, 1, 0, 0, 0, 643, 644, 3, 202, 101, 0, 644, 117, 1, 0, 0, 
	0, 645, 646, 3, 120, 60, 0, 646, 647, 5, 17, 0, 0, 647, 649, 1, 0, 0, 0, 
	648, 645, 1, 0, 0, 0, 649, 652, 1, 0, 0, 0, 650, 648, 1, 0, 0, 0, 650, 
	651, 1, 0, 0, 0, 651, 653, 1, 0, 0, 0, 652, 650, 1, 0, 0, 0, 653, 654, 
	3, 196, 98, 0, 654, 119, 1, 0, 0, 0, 655, 656, 3, 196, 98, 0, 656, 121, 
	1, 0, 0, 0, 657, 658, 6, 61, -1, 0, 658, 659, 3, 196, 98, 0, 659, 670, 
	1, 0, 0, 0, 660, 661, 10, 2, 0, 0, 661, 662, 5, 17, 0, 0, 662, 669, 3, 
	196, 98, 0, 663, 664, 10, 1, 0, 0, 664, 665, 5, 38, 0, 0, 665, 666, 3, 
	124, 62, 0, 666, 667, 5, 40, 0, 0, 667, 669, 1, 0, 0, 0, 668, 660, 1, 0, 
	0, 0, 668, 663, 1, 0, 0, 0, 669, 672, 1, 0, 0, 0, 670, 668, 1, 0, 0, 0, 
	670, 671, 1, 0, 0, 0, 671, 123, 1, 0, 0, 0, 672, 670, 1, 0, 0, 0, 673, 
	676, 5, 165, 0, 0, 674, 676, 5, 166, 0, 0, 675, 673, 1, 0, 0, 0, 675, 674, 
	1, 0, 0, 0, 676, 125, 1, 0, 0, 0, 677, 678, 6, 63, -1, 0, 678, 709, 3, 
	134, 67, 0, 679, 709, 3, 82, 41, 0, 680, 709, 3, 94, 47, 0, 681, 682, 5, 
	63, 0, 0, 682, 683, 3, 126, 63, 0, 683, 684, 5, 62, 0, 0, 684, 685, 3, 
	40, 20, 0, 685, 709, 1, 0, 0, 0, 686, 687, 5, 58, 0, 0, 687, 709, 3, 126, 
	63, 13, 688, 689, 5, 64, 0, 0, 689, 709, 3, 126, 63, 12, 690, 691, 5, 68, 
	0, 0, 691, 693, 5, 41, 0, 0, 692, 690, 1, 0, 0, 0, 692, 693, 1, 0, 0, 0, 
	693, 694, 1, 0, 0, 0, 694, 695, 3, 132, 66, 0, 695, 696, 5, 66, 0, 0, 696, 
	697, 3, 134, 67, 0, 697, 698, 5, 67, 0, 0, 698, 699, 3, 134, 67, 0, 699, 
	709, 1, 0, 0, 0, 700, 701, 5, 69, 0, 0, 701, 702, 5, 41, 0, 0, 702, 703, 
	3, 132, 66, 0, 703, 704, 5, 66, 0, 0, 704, 705, 3, 134, 67, 0, 705, 706, 
	5, 67, 0, 0, 706, 707, 3, 134, 67, 0, 707, 709, 1, 0, 0, 0, 708, 677, 1, 
	0, 0, 0, 708, 679, 1, 0, 0, 0, 708, 680, 1, 0, 0, 0, 708, 681, 1, 0, 0, 
	0, 708, 686, 1, 0, 0, 0, 708, 688, 1, 0, 0, 0, 708, 692, 1, 0, 0, 0, 708, 
	700, 1, 0, 0, 0, 709, 758, 1, 0, 0, 0, 710, 711, 10, 8, 0, 0, 711, 712, 
	7, 4, 0, 0, 712, 757, 3, 126, 63, 9, 713, 714, 10, 7, 0, 0, 714, 715, 3, 
	150, 75, 0, 715, 716, 3, 126, 63, 8, 716, 757, 1, 0, 0, 0, 717, 718, 10, 
	6, 0, 0, 718, 719, 7, 5, 0, 0, 719, 757, 3, 126, 63, 7, 720, 721, 10, 5, 
	0, 0, 721, 723, 7, 6, 0, 0, 722, 724, 3, 138, 69, 0, 723, 722, 1, 0, 0, 
	0, 723, 724, 1, 0, 0, 0, 724, 725, 1, 0, 0, 0, 725, 757, 3, 126, 63, 6, 
	726, 727, 10, 4, 0, 0, 727, 728, 5, 67, 0, 0, 728, 757, 3, 126, 63, 5, 
	729, 730, 10, 3, 0, 0, 730, 731, 7, 7, 0, 0, 731, 757, 3, 126, 63, 4, 732, 
	733, 10, 2, 0, 0, 733, 734, 5, 77, 0, 0, 734, 757, 3, 126, 63, 3, 735, 
	736, 10, 1, 0, 0, 736, 737, 7, 8, 0, 0, 737, 757, 3, 126, 63, 2, 738, 739, 
	10, 16, 0, 0, 739, 741, 5, 57, 0, 0, 740, 742, 5, 58, 0, 0, 741, 740, 1, 
	0, 0, 0, 741, 742, 1, 0, 0, 0, 742, 743, 1, 0, 0, 0, 743, 757, 7, 9, 0, 
	0, 744, 745, 10, 15, 0, 0, 745, 746, 7, 10, 0, 0, 746, 757, 3, 40, 20, 
	0, 747, 749, 10, 11, 0, 0, 748, 750, 5, 65, 0, 0, 749, 748, 1, 0, 0, 0, 
	749, 750, 1, 0, 0, 0, 750, 751, 1, 0, 0, 0, 751, 752, 5, 66, 0, 0, 752, 
	753, 3, 134, 67, 0, 753, 754, 5, 67, 0, 0, 754, 755, 3, 134, 67, 0, 755, 
	757, 1, 0, 0, 0, 756, 710, 1, 0, 0, 0, 756, 713, 1, 0, 0, 0, 756, 717, 
	1, 0, 0, 0, 756, 720, 1, 0, 0, 0, 756, 726, 1, 0, 0, 0, 756, 729, 1, 0, 
	0, 0, 756, 732, 1, 0, 0, 0, 756, 735, 1, 0, 0, 0, 756, 738, 1, 0, 0, 0, 
	756, 744, 1, 0, 0, 0, 756, 747, 1, 0, 0, 0, 757, 760, 1, 0, 0, 0, 758, 
	756, 1, 0, 0, 0, 758, 759, 1, 0, 0, 0, 759, 127, 1, 0, 0, 0, 760, 758, 
	1, 0, 0, 0, 761, 762, 7, 11, 0, 0, 762, 129, 1, 0, 0, 0, 763, 769, 3, 128, 
	64, 0, 764, 769, 5, 90, 0, 0, 765, 769, 5, 91, 0, 0, 766, 769, 5, 92, 0, 
	0, 767, 769, 5, 93, 0, 0, 768, 763, 1, 0, 0, 0, 768, 764, 1, 0, 0, 0, 768, 
	765, 1, 0, 0, 0, 768, 766, 1, 0, 0, 0, 768, 767, 1, 0, 0, 0, 769, 131, 
	1, 0, 0, 0, 770, 771, 7, 12, 0, 0, 771, 133, 1, 0, 0, 0, 772, 773, 6, 67, 
	-1, 0, 773, 851, 3, 152, 76, 0, 774, 775, 5, 102, 0, 0, 775, 776, 3, 126, 
	63, 0, 776, 779, 5, 103, 0, 0, 777, 780, 3, 40, 20, 0, 778, 780, 3, 210, 
	105, 0, 779, 777, 1, 0, 0, 0, 779, 778, 1, 0, 0, 0, 780, 851, 1, 0, 0, 
	0, 781, 782, 7, 13, 0, 0, 782, 851, 3, 134, 67, 18, 783, 784, 7, 14, 0, 
	0, 784, 785, 5, 108, 0, 0, 785, 851, 3, 134, 67, 17, 786, 787, 3, 130, 
	65, 0, 787, 788, 5, 19, 0, 0, 788, 789, 3, 134, 67, 16, 789, 851, 1, 0, 
	0, 0, 790, 791, 5, 68, 0, 0, 791, 792, 5, 41, 0, 0, 792, 793, 3, 132, 66, 
	0, 793, 794, 5, 108, 0, 0, 794, 795, 3, 134, 67, 15, 795, 851, 1, 0, 0, 
	0, 796, 797, 5, 69, 0, 0, 797, 798, 5, 41, 0, 0, 798, 799, 3, 132, 66, 
	0, 799, 800, 5, 108, 0, 0, 800, 801, 3, 134, 67, 14, 801, 851, 1, 0, 0, 
	0, 802, 803, 5, 109, 0, 0, 803, 804, 5, 108, 0, 0, 804, 851, 3, 134, 67, 
	13, 805, 806, 5, 110, 0, 0, 806, 807, 5, 108, 0, 0, 807, 851, 3, 134, 67, 
	12, 808, 809, 5, 111, 0, 0, 809, 810, 5, 108, 0, 0, 810, 851, 3, 134, 67, 
	11, 811, 812, 5, 112, 0, 0, 812, 813, 5, 19, 0, 0, 813, 851, 3, 134, 67, 
	10, 814, 815, 5, 113, 0, 0, 815, 816, 5, 19, 0, 0, 816, 851, 3, 134, 67, 
	9, 817, 818, 7, 15, 0, 0, 818, 851, 3, 42, 21, 0, 819, 820, 5, 122, 0, 
	0, 820, 821, 3, 126, 63, 0, 821, 822, 5, 123, 0, 0, 822, 823, 3, 126, 63, 
	0, 823, 824, 5, 124, 0, 0, 824, 825, 3, 126, 63, 0, 825, 851, 1, 0, 0, 
	0, 826, 828, 5, 125, 0, 0, 827, 829, 3, 126, 63, 0, 828, 827, 1, 0, 0, 
	0, 828, 829, 1, 0, 0, 0, 829, 831, 1, 0, 0, 0, 830, 832, 3, 136, 68, 0, 
	831, 830, 1, 0, 0, 0, 832, 833, 1, 0, 0, 0, 833, 831, 1, 0, 0, 0, 833, 
	834, 1, 0, 0, 0, 834, 835, 1, 0, 0, 0, 835, 836, 5, 124, 0, 0, 836, 837, 
	3, 126, 63, 0, 837, 838, 5, 107, 0, 0, 838, 851, 1, 0, 0, 0, 839, 840, 
	7, 16, 0, 0, 840, 851, 3, 126, 63, 0, 841, 842, 7, 17, 0, 0, 842, 848, 
	3, 126, 63, 0, 843, 846, 5, 129, 0, 0, 844, 847, 3, 128, 64, 0, 845, 847, 
	3, 126, 63, 0, 846, 844, 1, 0, 0, 0, 846, 845, 1, 0, 0, 0, 847, 849, 1, 
	0, 0, 0, 848, 843, 1, 0, 0, 0, 848, 849, 1, 0, 0, 0, 849, 851, 1, 0, 0, 
	0, 850, 772, 1, 0, 0, 0, 850, 774, 1, 0, 0, 0, 850, 781, 1, 0, 0, 0, 850, 
	783, 1, 0, 0, 0, 850, 786, 1, 0, 0, 0, 850, 790, 1, 0, 0, 0, 850, 796, 
	1, 0, 0, 0, 850, 802, 1, 0, 0, 0, 850, 805, 1, 0, 0, 0, 850, 808, 1, 0, 
	0, 0, 850, 811, 1, 0, 0, 0, 850, 814, 1, 0, 0, 0, 850, 817, 1, 0, 0, 0, 
	850, 819, 1, 0, 0, 0, 850, 826, 1, 0, 0, 0, 850, 839, 1, 0, 0, 0, 850, 
	841, 1, 0, 0, 0, 851, 871, 1, 0, 0, 0, 852, 853, 10, 7, 0, 0, 853, 854, 
	5, 116, 0, 0, 854, 870, 3, 134, 67, 8, 855, 856, 10, 6, 0, 0, 856, 857, 
	7, 18, 0, 0, 857, 870, 3, 134, 67, 7, 858, 859, 10, 5, 0, 0, 859, 860, 
	7, 19, 0, 0, 860, 870, 3, 134, 67, 6, 861, 862, 10, 21, 0, 0, 862, 863, 
	5, 17, 0, 0, 863, 870, 3, 154, 77, 0, 864, 865, 10, 20, 0, 0, 865, 866, 
	5, 38, 0, 0, 866, 867, 3, 126, 63, 0, 867, 868, 5, 40, 0, 0, 868, 870, 
	1, 0, 0, 0, 869, 852, 1, 0, 0, 0, 869, 855, 1, 0, 0, 0, 869, 858, 1, 0, 
	0, 0, 869, 861, 1, 0, 0, 0, 869, 864, 1, 0, 0, 0, 870, 873, 1, 0, 0, 0, 
	871, 869, 1, 0, 0, 0, 871, 872, 1, 0, 0, 0, 872, 135, 1, 0, 0, 0, 873, 
	871, 1, 0, 0, 0, 874, 875, 5, 130, 0, 0, 875, 876, 3, 126, 63, 0, 876, 
	877, 5, 123, 0, 0, 877, 878, 3, 126, 63, 0, 878, 137, 1, 0, 0, 0, 879, 
	880, 3, 128, 64, 0, 880, 881, 5, 108, 0, 0, 881, 139, 1, 0, 0, 0, 882, 
	883, 7, 20, 0, 0, 883, 141, 1, 0, 0, 0, 884, 885, 7, 21, 0, 0, 885, 143, 
	1, 0, 0, 0, 886, 887, 7, 22, 0, 0, 887, 145, 1, 0, 0, 0, 888, 890, 3, 208, 
	104, 0, 889, 891, 3, 142, 71, 0, 890, 889, 1, 0, 0, 0, 890, 891, 1, 0, 
	0, 0, 891, 896, 1, 0, 0, 0, 892, 893, 3, 144, 72, 0, 893, 894, 3, 208, 
	104, 0, 894, 896, 1, 0, 0, 0, 895, 888, 1, 0, 0, 0, 895, 892, 1, 0, 0, 
	0, 896, 147, 1, 0, 0, 0, 897, 899, 5, 137, 0, 0, 898, 897, 1, 0, 0, 0, 
	898, 899, 1, 0, 0, 0, 899, 900, 1, 0, 0, 0, 900, 906, 7, 23, 0, 0, 901, 
	903, 7, 23, 0, 0, 902, 904, 5, 140, 0, 0, 903, 902, 1, 0, 0, 0, 903, 904, 
	1, 0, 0, 0, 904, 906, 1, 0, 0, 0, 905, 898, 1, 0, 0, 0, 905, 901, 1, 0, 
	0, 0, 906, 149, 1, 0, 0, 0, 907, 909, 7, 24, 0, 0, 908, 907, 1, 0, 0, 0, 
	908, 909, 1, 0, 0, 0, 909, 910, 1, 0, 0, 0, 910, 912, 5, 144, 0, 0, 911, 
	913, 3, 128, 64, 0, 912, 911, 1, 0, 0, 0, 912, 913, 1, 0, 0, 0, 913, 916, 
	1, 0, 0, 0, 914, 917, 3, 140, 70, 0, 915, 917, 5, 62, 0, 0, 916, 914, 1, 
	0, 0, 0, 916, 915, 1, 0, 0, 0, 917, 919, 1, 0, 0, 0, 918, 920, 7, 14, 0, 
	0, 919, 918, 1, 0, 0, 0, 919, 920, 1, 0, 0, 0, 920, 989, 1, 0, 0, 0, 921, 
	923, 5, 65, 0, 0, 922, 921, 1, 0, 0, 0, 922, 923, 1, 0, 0, 0, 923, 924, 
	1, 0, 0, 0, 924, 926, 5, 145, 0, 0, 925, 927, 3, 138, 69, 0, 926, 925, 
	1, 0, 0, 0, 926, 927, 1, 0, 0, 0, 927, 929, 1, 0, 0, 0, 928, 930, 7, 14, 
	0, 0, 929, 928, 1, 0, 0, 0, 929, 930, 1, 0, 0, 0, 930, 989, 1, 0, 0, 0, 
	931, 933, 7, 24, 0, 0, 932, 931, 1, 0, 0, 0, 932, 933, 1, 0, 0, 0, 933, 
	935, 1, 0, 0, 0, 934, 936, 5, 65, 0, 0, 935, 934, 1, 0, 0, 0, 935, 936, 
	1, 0, 0, 0, 936, 937, 1, 0, 0, 0, 937, 939, 7, 25, 0, 0, 938, 940, 3, 138, 
	69, 0, 939, 938, 1, 0, 0, 0, 939, 940, 1, 0, 0, 0, 940, 989, 1, 0, 0, 0, 
	941, 943, 7, 24, 0, 0, 942, 941, 1, 0, 0, 0, 942, 943, 1, 0, 0, 0, 943, 
	945, 1, 0, 0, 0, 944, 946, 3, 146, 73, 0, 945, 944, 1, 0, 0, 0, 945, 946, 
	1, 0, 0, 0, 946, 947, 1, 0, 0, 0, 947, 949, 3, 148, 74, 0, 948, 950, 3, 
	138, 69, 0, 949, 948, 1, 0, 0, 0, 949, 950, 1, 0, 0, 0, 950, 952, 1, 0, 
	0, 0, 951, 953, 7, 14, 0, 0, 952, 951, 1, 0, 0, 0, 952, 953, 1, 0, 0, 0, 
	953, 989, 1, 0, 0, 0, 954, 956, 7, 24, 0, 0, 955, 954, 1, 0, 0, 0, 955, 
	956, 1, 0, 0, 0, 956, 958, 1, 0, 0, 0, 957, 959, 5, 65, 0, 0, 958, 957, 
	1, 0, 0, 0, 958, 959, 1, 0, 0, 0, 959, 960, 1, 0, 0, 0, 960, 961, 5, 148, 
	0, 0, 961, 962, 3, 208, 104, 0, 962, 964, 5, 108, 0, 0, 963, 965, 7, 14, 
	0, 0, 964, 963, 1, 0, 0, 0, 964, 965, 1, 0, 0, 0, 965, 989, 1, 0, 0, 0, 
	966, 968, 5, 149, 0, 0, 967, 969, 7, 23, 0, 0, 968, 967, 1, 0, 0, 0, 968, 
	969, 1, 0, 0, 0, 969, 971, 1, 0, 0, 0, 970, 972, 3, 138, 69, 0, 971, 970, 
	1, 0, 0, 0, 971, 972, 1, 0, 0, 0, 972, 989, 1, 0, 0, 0, 973, 975, 5, 150, 
	0, 0, 974, 976, 7, 23, 0, 0, 975, 974, 1, 0, 0, 0, 975, 976, 1, 0, 0, 0, 
	976, 978, 1, 0, 0, 0, 977, 979, 3, 138, 69, 0, 978, 977, 1, 0, 0, 0, 978, 
	979, 1, 0, 0, 0, 979, 989, 1, 0, 0, 0, 980, 982, 5, 141, 0, 0, 981, 983, 
	3, 138, 69, 0, 982, 981, 1, 0, 0, 0, 982, 983, 1, 0, 0, 0, 983, 989, 1, 
	0, 0, 0, 984, 986, 5, 142, 0, 0, 985, 987, 3, 138, 69, 0, 986, 985, 1, 
	0, 0, 0, 986, 987, 1, 0, 0, 0, 987, 989, 1, 0, 0, 0, 988, 908, 1, 0, 0, 
	0, 988, 922, 1, 0, 0, 0, 988, 932, 1, 0, 0, 0, 988, 942, 1, 0, 0, 0, 988, 
	955, 1, 0, 0, 0, 988, 966, 1, 0, 0, 0, 988, 973, 1, 0, 0, 0, 988, 980, 
	1, 0, 0, 0, 988, 984, 1, 0, 0, 0, 989, 151, 1, 0, 0, 0, 990, 1004, 3, 158, 
	79, 0, 991, 1004, 3, 164, 82, 0, 992, 1004, 3, 204, 102, 0, 993, 1004, 
	3, 166, 83, 0, 994, 1004, 3, 168, 84, 0, 995, 1004, 3, 172, 86, 0, 996, 
	1004, 3, 176, 88, 0, 997, 1004, 3, 180, 90, 0, 998, 1004, 3, 182, 91, 0, 
	999, 1000, 5, 31, 0, 0, 1000, 1001, 3, 126, 63, 0, 1001, 1002, 5, 32, 0, 
	0, 1002, 1004, 1, 0, 0, 0, 1003, 990, 1, 0, 0, 0, 1003, 991, 1, 0, 0, 0, 
	1003, 992, 1, 0, 0, 0, 1003, 993, 1, 0, 0, 0, 1003, 994, 1, 0, 0, 0, 1003, 
	995, 1, 0, 0, 0, 1003, 996, 1, 0, 0, 0, 1003, 997, 1, 0, 0, 0, 1003, 998, 
	1, 0, 0, 0, 1003, 999, 1, 0, 0, 0, 1004, 153, 1, 0, 0, 0, 1005, 1008, 3, 
	196, 98, 0, 1006, 1008, 3, 156, 78, 0, 1007, 1005, 1, 0, 0, 0, 1007, 1006, 
	1, 0, 0, 0, 1008, 155, 1, 0, 0, 0, 1009, 1010, 3, 200, 100, 0, 1010, 1012, 
	5, 31, 0, 0, 1011, 1013, 3, 206, 103, 0, 1012, 1011, 1, 0, 0, 0, 1012, 
	1013, 1, 0, 0, 0, 1013, 1014, 1, 0, 0, 0, 1014, 1015, 5, 32, 0, 0, 1015, 
	157, 1, 0, 0, 0, 1016, 1022, 3, 196, 98, 0, 1017, 1022, 3, 160, 80, 0, 
	1018, 1022, 5, 151, 0, 0, 1019, 1022, 5, 152, 0, 0, 1020, 1022, 5, 153, 
	0, 0, 1021, 1016, 1, 0, 0, 0, 1021, 1017, 1, 0, 0, 0, 1021, 1018, 1, 0, 
	0, 0, 1021, 1019, 1, 0, 0, 0, 1021, 1020, 1, 0, 0, 0, 1022, 159, 1, 0, 
	0, 0, 1023, 1024, 3, 196, 98, 0, 1024, 1026, 5, 31, 0, 0, 1025, 1027, 3, 
	206, 103, 0, 1026, 1025, 1, 0, 0, 0, 1026, 1027, 1, 0, 0, 0, 1027, 1028, 
	1, 0, 0, 0, 1028, 1029, 5, 32, 0, 0, 1029, 161, 1, 0, 0, 0, 1030, 1031, 
	3, 208, 104, 0, 1031, 1032, 5, 11, 0, 0, 1032, 1033, 3, 208, 104, 0, 1033, 
	163, 1, 0, 0, 0, 1034, 1045, 7, 26, 0, 0, 1035, 1045, 5, 59, 0, 0, 1036, 
	1045, 5, 165, 0, 0, 1037, 1045, 5, 166, 0, 0, 1038, 1045, 5, 160, 0, 0, 
	1039, 1045, 5, 159, 0, 0, 1040, 1045, 5, 161, 0, 0, 1041, 1045, 5, 162, 
	0, 0, 1042, 1045, 3, 208, 104, 0, 1043, 1045, 3, 162, 81, 0, 1044, 1034, 
	1, 0, 0, 0, 1044, 1035, 1, 0, 0, 0, 1044, 1036, 1, 0, 0, 0, 1044, 1037, 
	1, 0, 0, 0, 1044, 1038, 1, 0, 0, 0, 1044, 1039, 1, 0, 0, 0, 1044, 1040, 
	1, 0, 0, 0, 1044, 1041, 1, 0, 0, 0, 1044, 1042, 1, 0, 0, 0, 1044, 1043, 
	1, 0, 0, 0, 1045, 165, 1, 0, 0, 0, 1046, 1047, 5, 24, 0, 0, 1047, 1048, 
	7, 27, 0, 0, 1048, 1049, 3, 126, 63, 0, 1049, 1050, 5, 15, 0, 0, 1050, 
	1051, 3, 126, 63, 0, 1051, 1052, 7, 28, 0, 0, 1052, 167, 1, 0, 0, 0, 1053, 
	1055, 5, 25, 0, 0, 1054, 1053, 1, 0, 0, 0, 1054, 1055, 1, 0, 0, 0, 1055, 
	1056, 1, 0, 0, 0, 1056, 1066, 5, 14, 0, 0, 1057, 1067, 5, 11, 0, 0, 1058, 
	1063, 3, 170, 85, 0, 1059, 1060, 5, 15, 0, 0, 1060, 1062, 3, 170, 85, 0, 
	1061, 1059, 1, 0, 0, 0, 1062, 1065, 1, 0, 0, 0, 1063, 1061, 1, 0, 0, 0, 
	1063, 1064, 1, 0, 0, 0, 1064, 1067, 1, 0, 0, 0, 1065, 1063, 1, 0, 0, 0, 
	1066, 1057, 1, 0, 0, 0, 1066, 1058, 1, 0, 0, 0, 1067, 1068, 1, 0, 0, 0, 
	1068, 1069, 5, 16, 0, 0, 1069, 169, 1, 0, 0, 0, 1070, 1071, 3, 196, 98, 
	0, 1071, 1072, 5, 11, 0, 0, 1072, 1073, 3, 126, 63, 0, 1073, 171, 1, 0, 
	0, 0, 1074, 1075, 3, 42, 21, 0, 1075, 1085, 5, 14, 0, 0, 1076, 1086, 5, 
	11, 0, 0, 1077, 1082, 3, 174, 87, 0, 1078, 1079, 5, 15, 0, 0, 1079, 1081, 
	3, 174, 87, 0, 1080, 1078, 1, 0, 0, 0, 1081, 1084, 1, 0, 0, 0, 1082, 1080, 
	1, 0, 0, 0, 1082, 1083, 1, 0, 0, 0, 1083, 1086, 1, 0, 0, 0, 1084, 1082, 
	1, 0, 0, 0, 1085, 1076, 1, 0, 0, 0, 1085, 1077, 1, 0, 0, 0, 1086, 1087, 
	1, 0, 0, 0, 1087, 1088, 5, 16, 0, 0, 1088, 173, 1, 0, 0, 0, 1089, 1090, 
	3, 196, 98, 0, 1090, 1091, 5, 11, 0, 0, 1091, 1092, 3, 126, 63, 0, 1092, 
	175, 1, 0, 0, 0, 1093, 1098, 5, 21, 0, 0, 1094, 1095, 5, 22, 0, 0, 1095, 
	1096, 3, 40, 20, 0, 1096, 1097, 5, 23, 0, 0, 1097, 1099, 1, 0, 0, 0, 1098, 
	1094, 1, 0, 0, 0, 1098, 1099, 1, 0, 0, 0, 1099, 1101, 1, 0, 0, 0, 1100, 
	1093, 1, 0, 0, 0, 1100, 1101, 1, 0, 0, 0, 1101, 1102, 1, 0, 0, 0, 1102, 
	1111, 5, 14, 0, 0, 1103, 1108, 3, 126, 63, 0, 1104, 1105, 5, 15, 0, 0, 
	1105, 1107, 3, 126, 63, 0, 1106, 1104, 1, 0, 0, 0, 1107, 1110, 1, 0, 0, 
	0, 1108, 1106, 1, 0, 0, 0, 1108, 1109, 1, 0, 0, 0, 1109, 1112, 1, 0, 0, 
	0, 1110, 1108, 1, 0, 0, 0, 1111, 1103, 1, 0, 0, 0, 1111, 1112, 1, 0, 0, 
	0, 1112, 1113, 1, 0, 0, 0, 1113, 1114, 5, 16, 0, 0, 1114, 177, 1, 0, 0, 
	0, 1115, 1116, 5, 154, 0, 0, 1116, 1117, 5, 165, 0, 0, 1117, 179, 1, 0, 
	0, 0, 1118, 1119, 5, 155, 0, 0, 1119, 1120, 5, 165, 0, 0, 1120, 1121, 5, 
	19, 0, 0, 1121, 1123, 3, 22, 11, 0, 1122, 1124, 3, 178, 89, 0, 1123, 1122, 
	1, 0, 0, 0, 1123, 1124, 1, 0, 0, 0, 1124, 181, 1, 0, 0, 0, 1125, 1126, 
	5, 156, 0, 0, 1126, 1127, 5, 14, 0, 0, 1127, 1132, 3, 180, 90, 0, 1128, 
	1129, 5, 15, 0, 0, 1129, 1131, 3, 180, 90, 0, 1130, 1128, 1, 0, 0, 0, 1131, 
	1134, 1, 0, 0, 0, 1132, 1130, 1, 0, 0, 0, 1132, 1133, 1, 0, 0, 0, 1133, 
	1135, 1, 0, 0, 0, 1134, 1132, 1, 0, 0, 0, 1135, 1137, 5, 16, 0, 0, 1136, 
	1138, 3, 178, 89, 0, 1137, 1136, 1, 0, 0, 0, 1137, 1138, 1, 0, 0, 0, 1138, 
	183, 1, 0, 0, 0, 1139, 1140, 7, 29, 0, 0, 1140, 185, 1, 0, 0, 0, 1141, 
	1142, 7, 30, 0, 0, 1142, 187, 1, 0, 0, 0, 1143, 1144, 7, 31, 0, 0, 1144, 
	189, 1, 0, 0, 0, 1145, 1146, 7, 32, 0, 0, 1146, 191, 1, 0, 0, 0, 1147, 
	1148, 7, 33, 0, 0, 1148, 193, 1, 0, 0, 0, 1149, 1150, 7, 34, 0, 0, 1150, 
	195, 1, 0, 0, 0, 1151, 1154, 3, 202, 101, 0, 1152, 1154, 3, 188, 94, 0, 
	1153, 1151, 1, 0, 0, 0, 1153, 1152, 1, 0, 0, 0, 1154, 197, 1, 0, 0, 0, 
	1155, 1158, 3, 196, 98, 0, 1156, 1158, 3, 194, 97, 0, 1157, 1155, 1, 0, 
	0, 0, 1157, 1156, 1, 0, 0, 0, 1158, 199, 1, 0, 0, 0, 1159, 1162, 3, 202, 
	101, 0, 1160, 1162, 3, 192, 96, 0, 1161, 1159, 1, 0, 0, 0, 1161, 1160, 
	1, 0, 0, 0, 1162, 201, 1, 0, 0, 0, 1163, 1164, 7, 35, 0, 0, 1164, 203, 
	1, 0, 0, 0, 1165, 1168, 5, 157, 0, 0, 1166, 1169, 3, 202, 101, 0, 1167, 
	1169, 5, 165, 0, 0, 1168, 1166, 1, 0, 0, 0, 1168, 1167, 1, 0, 0, 0, 1169, 
	205, 1, 0, 0, 0, 1170, 1175, 3, 126, 63, 0, 1171, 1172, 5, 15, 0, 0, 1172, 
	1174, 3, 126, 63, 0, 1173, 1171, 1, 0, 0, 0, 1174, 1177, 1, 0, 0, 0, 1175, 
	1173, 1, 0, 0, 0, 1175, 1176, 1, 0, 0, 0, 1176, 207, 1, 0, 0, 0, 1177, 
	1175, 1, 0, 0, 0, 1178, 1180, 5, 166, 0, 0, 1179, 1181, 3, 210, 105, 0, 
	1180, 1179, 1, 0, 0, 0, 1180, 1181, 1, 0, 0, 0, 1181, 209, 1, 0, 0, 0, 
	1182, 1186, 3, 128, 64, 0, 1183, 1186, 3, 132, 66, 0, 1184, 1186, 5, 165, 
	0, 0, 1185, 1182, 1, 0, 0, 0, 1185, 1183, 1, 0, 0, 0, 1185, 1184, 1, 0, 
	0, 0, 1186, 211, 1, 0, 0, 0, 134, 219, 222, 227, 233, 242, 248, 252, 258, 
	262, 269, 274, 278, 281, 289, 292, 300, 303, 312, 320, 327, 336, 339, 350, 
	355, 360, 377, 384, 408, 423, 431, 435, 445, 453, 456, 466, 469, 474, 479, 
	492, 501, 517, 524, 527, 539, 545, 550, 554, 558, 561, 564, 571, 580, 592, 
	598, 602, 614, 624, 627, 633, 640, 650, 668, 670, 675, 692, 708, 723, 741, 
	749, 756, 758, 768, 779, 828, 833, 846, 848, 850, 869, 871, 890, 895, 898, 
	903, 905, 908, 912, 916, 919, 922, 926, 929, 932, 935, 939, 942, 945, 949, 
	952, 955, 958, 964, 968, 971, 975, 978, 982, 986, 988, 1003, 1007, 1012, 
	1021, 1026, 1044, 1054, 1063, 1066, 1082, 1085, 1098, 1100, 1108, 1111, 
	1123, 1132, 1137, 1153, 1157, 1161, 1168, 1175, 1180, 1185,
}
  deserializer := antlr.NewATNDeserializer(nil)
  staticData.atn = deserializer.Deserialize(staticData.serializedATN)
  atn := staticData.atn
  staticData.decisionToDFA = make([]*antlr.DFA, len(atn.DecisionToState))
  decisionToDFA := staticData.decisionToDFA
  for index, state := range atn.DecisionToState {
    decisionToDFA[index] = antlr.NewDFA(state, index)
  }
}

// CqlParserInit initializes any static state used to implement CqlParser. By default the
// static state used to implement the parser is lazily initialized during the first call to
// NewCqlParser(). You can call this function if you wish to initialize the static state ahead
// of time.
func CqlParserInit() {
  staticData := &CqlParserStaticData
  staticData.once.Do(cqlParserInit)
}

// NewCqlParser produces a new parser instance for the optional input antlr.TokenStream.
func NewCqlParser(input antlr.TokenStream) *CqlParser {
	CqlParserInit()
	this := new(CqlParser)
	this.BaseParser = antlr.NewBaseParser(input)
  staticData := &CqlParserStaticData
	this.Interpreter = antlr.NewParserATNSimulator(this, staticData.atn, staticData.decisionToDFA, staticData.PredictionContextCache)
	this.RuleNames = staticData.RuleNames
	this.LiteralNames = staticData.LiteralNames
	this.SymbolicNames = staticData.SymbolicNames
	this.GrammarFileName = "Cql.g4"

	return this
}


// CqlParser tokens.
const (
	CqlParserEOF = antlr.TokenEOF
	CqlParserT__0 = 1
	CqlParserT__1 = 2
	CqlParserT__2 = 3
	CqlParserT__3 = 4
	CqlParserT__4 = 5
	CqlParserT__5 = 6
	CqlParserT__6 = 7
	CqlParserT__7 = 8
	CqlParserT__8 = 9
	CqlParserT__9 = 10
	CqlParserT__10 = 11
	CqlParserT__11 = 12
	CqlParserT__12 = 13
	CqlParserT__13 = 14
	CqlParserT__14 = 15
	CqlParserT__15 = 16
	CqlParserT__16 = 17
	CqlParserT__17 = 18
	CqlParserT__18 = 19
	CqlParserT__19 = 20
	CqlParserT__20 = 21
	CqlParserT__21 = 22
	CqlParserT__22 = 23
	CqlParserT__23 = 24
	CqlParserT__24 = 25
	CqlParserT__25 = 26
	CqlParserT__26 = 27
	CqlParserT__27 = 28
	CqlParserT__28 = 29
	CqlParserT__29 = 30
	CqlParserT__30 = 31
	CqlParserT__31 = 32
	CqlParserT__32 = 33
	CqlParserT__33 = 34
	CqlParserT__34 = 35
	CqlParserT__35 = 36
	CqlParserT__36 = 37
	CqlParserT__37 = 38
	CqlParserT__38 = 39
	CqlParserT__39 = 40
	CqlParserT__40 = 41
	CqlParserT__41 = 42
	CqlParserT__42 = 43
	CqlParserT__43 = 44
	CqlParserT__44 = 45
	CqlParserT__45 = 46
	CqlParserT__46 = 47
	CqlParserT__47 = 48
	CqlParserT__48 = 49
	CqlParserT__49 = 50
	CqlParserT__50 = 51
	CqlParserT__51 = 52
	CqlParserT__52 = 53
	CqlParserT__53 = 54
	CqlParserT__54 = 55
	CqlParserT__55 = 56
	CqlParserT__56 = 57
	CqlParserT__57 = 58
	CqlParserT__58 = 59
	CqlParserT__59 = 60
	CqlParserT__60 = 61
	CqlParserT__61 = 62
	CqlParserT__62 = 63
	CqlParserT__63 = 64
	CqlParserT__64 = 65
	CqlParserT__65 = 66
	CqlParserT__66 = 67
	CqlParserT__67 = 68
	CqlParserT__68 = 69
	CqlParserT__69 = 70
	CqlParserT__70 = 71
	CqlParserT__71 = 72
	CqlParserT__72 = 73
	CqlParserT__73 = 74
	CqlParserT__74 = 75
	CqlParserT__75 = 76
	CqlParserT__76 = 77
	CqlParserT__77 = 78
	CqlParserT__78 = 79
	CqlParserT__79 = 80
	CqlParserT__80 = 81
	CqlParserT__81 = 82
	CqlParserT__82 = 83
	CqlParserT__83 = 84
	CqlParserT__84 = 85
	CqlParserT__85 = 86
	CqlParserT__86 = 87
	CqlParserT__87 = 88
	CqlParserT__88 = 89
	CqlParserT__89 = 90
	CqlParserT__90 = 91
	CqlParserT__91 = 92
	CqlParserT__92 = 93
	CqlParserT__93 = 94
	CqlParserT__94 = 95
	CqlParserT__95 = 96
	CqlParserT__96 = 97
	CqlParserT__97 = 98
	CqlParserT__98 = 99
	CqlParserT__99 = 100
	CqlParserT__100 = 101
	CqlParserT__101 = 102
	CqlParserT__102 = 103
	CqlParserT__103 = 104
	CqlParserT__104 = 105
	CqlParserT__105 = 106
	CqlParserT__106 = 107
	CqlParserT__107 = 108
	CqlParserT__108 = 109
	CqlParserT__109 = 110
	CqlParserT__110 = 111
	CqlParserT__111 = 112
	CqlParserT__112 = 113
	CqlParserT__113 = 114
	CqlParserT__114 = 115
	CqlParserT__115 = 116
	CqlParserT__116 = 117
	CqlParserT__117 = 118
	CqlParserT__118 = 119
	CqlParserT__119 = 120
	CqlParserT__120 = 121
	CqlParserT__121 = 122
	CqlParserT__122 = 123
	CqlParserT__123 = 124
	CqlParserT__124 = 125
	CqlParserT__125 = 126
	CqlParserT__126 = 127
	CqlParserT__127 = 128
	CqlParserT__128 = 129
	CqlParserT__129 = 130
	CqlParserT__130 = 131
	CqlParserT__131 = 132
	CqlParserT__132 = 133
	CqlParserT__133 = 134
	CqlParserT__134 = 135
	CqlParserT__135 = 136
	CqlParserT__136 = 137
	CqlParserT__137 = 138
	CqlParserT__138 = 139
	CqlParserT__139 = 140
	CqlParserT__140 = 141
	CqlParserT__141 = 142
	CqlParserT__142 = 143
	CqlParserT__143 = 144
	CqlParserT__144 = 145
	CqlParserT__145 = 146
	CqlParserT__146 = 147
	CqlParserT__147 = 148
	CqlParserT__148 = 149
	CqlParserT__149 = 150
	CqlParserT__150 = 151
	CqlParserT__151 = 152
	CqlParserT__152 = 153
	CqlParserT__153 = 154
	CqlParserT__154 = 155
	CqlParserT__155 = 156
	CqlParserT__156 = 157
	CqlParserQUOTEDIDENTIFIER = 158
	CqlParserDATETIME = 159
	CqlParserLONGNUMBER = 160
	CqlParserDATE = 161
	CqlParserTIME = 162
	CqlParserIDENTIFIER = 163
	CqlParserDELIMITEDIDENTIFIER = 164
	CqlParserSTRING = 165
	CqlParserNUMBER = 166
	CqlParserWS = 167
	CqlParserCOMMENT = 168
	CqlParserLINE_COMMENT = 169
)

// CqlParser rules.
const (
	CqlParserRULE_definition = 0
	CqlParserRULE_library = 1
	CqlParserRULE_libraryDefinition = 2
	CqlParserRULE_usingDefinition = 3
	CqlParserRULE_includeDefinition = 4
	CqlParserRULE_localIdentifier = 5
	CqlParserRULE_accessModifier = 6
	CqlParserRULE_parameterDefinition = 7
	CqlParserRULE_codesystemDefinition = 8
	CqlParserRULE_valuesetDefinition = 9
	CqlParserRULE_codesystems = 10
	CqlParserRULE_codesystemIdentifier = 11
	CqlParserRULE_libraryIdentifier = 12
	CqlParserRULE_codeDefinition = 13
	CqlParserRULE_conceptDefinition = 14
	CqlParserRULE_codeIdentifier = 15
	CqlParserRULE_codesystemId = 16
	CqlParserRULE_valuesetId = 17
	CqlParserRULE_versionSpecifier = 18
	CqlParserRULE_codeId = 19
	CqlParserRULE_typeSpecifier = 20
	CqlParserRULE_namedTypeSpecifier = 21
	CqlParserRULE_modelIdentifier = 22
	CqlParserRULE_listTypeSpecifier = 23
	CqlParserRULE_intervalTypeSpecifier = 24
	CqlParserRULE_tupleTypeSpecifier = 25
	CqlParserRULE_tupleElementDefinition = 26
	CqlParserRULE_choiceTypeSpecifier = 27
	CqlParserRULE_statement = 28
	CqlParserRULE_expressionDefinition = 29
	CqlParserRULE_contextDefinition = 30
	CqlParserRULE_fluentModifier = 31
	CqlParserRULE_functionDefinition = 32
	CqlParserRULE_operandDefinition = 33
	CqlParserRULE_functionBody = 34
	CqlParserRULE_querySource = 35
	CqlParserRULE_aliasedQuerySource = 36
	CqlParserRULE_alias = 37
	CqlParserRULE_queryInclusionClause = 38
	CqlParserRULE_withClause = 39
	CqlParserRULE_withoutClause = 40
	CqlParserRULE_retrieve = 41
	CqlParserRULE_contextIdentifier = 42
	CqlParserRULE_codePath = 43
	CqlParserRULE_codeComparator = 44
	CqlParserRULE_terminology = 45
	CqlParserRULE_qualifier = 46
	CqlParserRULE_query = 47
	CqlParserRULE_sourceClause = 48
	CqlParserRULE_letClause = 49
	CqlParserRULE_letClauseItem = 50
	CqlParserRULE_whereClause = 51
	CqlParserRULE_returnClause = 52
	CqlParserRULE_aggregateClause = 53
	CqlParserRULE_startingClause = 54
	CqlParserRULE_sortClause = 55
	CqlParserRULE_sortDirection = 56
	CqlParserRULE_sortByItem = 57
	CqlParserRULE_qualifiedIdentifier = 58
	CqlParserRULE_qualifiedIdentifierExpression = 59
	CqlParserRULE_qualifierExpression = 60
	CqlParserRULE_simplePath = 61
	CqlParserRULE_simpleLiteral = 62
	CqlParserRULE_expression = 63
	CqlParserRULE_dateTimePrecision = 64
	CqlParserRULE_dateTimeComponent = 65
	CqlParserRULE_pluralDateTimePrecision = 66
	CqlParserRULE_expressionTerm = 67
	CqlParserRULE_caseExpressionItem = 68
	CqlParserRULE_dateTimePrecisionSpecifier = 69
	CqlParserRULE_relativeQualifier = 70
	CqlParserRULE_offsetRelativeQualifier = 71
	CqlParserRULE_exclusiveRelativeQualifier = 72
	CqlParserRULE_quantityOffset = 73
	CqlParserRULE_temporalRelationship = 74
	CqlParserRULE_intervalOperatorPhrase = 75
	CqlParserRULE_term = 76
	CqlParserRULE_qualifiedInvocation = 77
	CqlParserRULE_qualifiedFunction = 78
	CqlParserRULE_invocation = 79
	CqlParserRULE_function = 80
	CqlParserRULE_ratio = 81
	CqlParserRULE_literal = 82
	CqlParserRULE_intervalSelector = 83
	CqlParserRULE_tupleSelector = 84
	CqlParserRULE_tupleElementSelector = 85
	CqlParserRULE_instanceSelector = 86
	CqlParserRULE_instanceElementSelector = 87
	CqlParserRULE_listSelector = 88
	CqlParserRULE_displayClause = 89
	CqlParserRULE_codeSelector = 90
	CqlParserRULE_conceptSelector = 91
	CqlParserRULE_keyword = 92
	CqlParserRULE_reservedWord = 93
	CqlParserRULE_keywordIdentifier = 94
	CqlParserRULE_obsoleteIdentifier = 95
	CqlParserRULE_functionIdentifier = 96
	CqlParserRULE_typeNameIdentifier = 97
	CqlParserRULE_referentialIdentifier = 98
	CqlParserRULE_referentialOrTypeNameIdentifier = 99
	CqlParserRULE_identifierOrFunctionIdentifier = 100
	CqlParserRULE_identifier = 101
	CqlParserRULE_externalConstant = 102
	CqlParserRULE_paramList = 103
	CqlParserRULE_quantity = 104
	CqlParserRULE_unit = 105
)

// IDefinitionContext is an interface to support dynamic dispatch.
type IDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	UsingDefinition() IUsingDefinitionContext
	IncludeDefinition() IIncludeDefinitionContext
	CodesystemDefinition() ICodesystemDefinitionContext
	ValuesetDefinition() IValuesetDefinitionContext
	CodeDefinition() ICodeDefinitionContext
	ConceptDefinition() IConceptDefinitionContext
	ParameterDefinition() IParameterDefinitionContext

	// IsDefinitionContext differentiates from other interfaces.
	IsDefinitionContext()
}

type DefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDefinitionContext() *DefinitionContext {
	var p = new(DefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_definition
	return p
}

func InitEmptyDefinitionContext(p *DefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_definition
}

func (*DefinitionContext) IsDefinitionContext() {}

func NewDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DefinitionContext {
	var p = new(DefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_definition

	return p
}

func (s *DefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *DefinitionContext) UsingDefinition() IUsingDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUsingDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUsingDefinitionContext)
}

func (s *DefinitionContext) IncludeDefinition() IIncludeDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIncludeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIncludeDefinitionContext)
}

func (s *DefinitionContext) CodesystemDefinition() ICodesystemDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemDefinitionContext)
}

func (s *DefinitionContext) ValuesetDefinition() IValuesetDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesetDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesetDefinitionContext)
}

func (s *DefinitionContext) CodeDefinition() ICodeDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeDefinitionContext)
}

func (s *DefinitionContext) ConceptDefinition() IConceptDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptDefinitionContext)
}

func (s *DefinitionContext) ParameterDefinition() IParameterDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParameterDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParameterDefinitionContext)
}

func (s *DefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Definition() (localctx IDefinitionContext) {
	localctx = NewDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, CqlParserRULE_definition)
	p.SetState(219)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 0, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(212)
			p.UsingDefinition()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(213)
			p.IncludeDefinition()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(214)
			p.CodesystemDefinition()
		}


	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(215)
			p.ValuesetDefinition()
		}


	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(216)
			p.CodeDefinition()
		}


	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(217)
			p.ConceptDefinition()
		}


	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(218)
			p.ParameterDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILibraryContext is an interface to support dynamic dispatch.
type ILibraryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	EOF() antlr.TerminalNode
	LibraryDefinition() ILibraryDefinitionContext
	AllDefinition() []IDefinitionContext
	Definition(i int) IDefinitionContext
	AllStatement() []IStatementContext
	Statement(i int) IStatementContext

	// IsLibraryContext differentiates from other interfaces.
	IsLibraryContext()
}

type LibraryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryContext() *LibraryContext {
	var p = new(LibraryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_library
	return p
}

func InitEmptyLibraryContext(p *LibraryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_library
}

func (*LibraryContext) IsLibraryContext() {}

func NewLibraryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryContext {
	var p = new(LibraryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_library

	return p
}

func (s *LibraryContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryContext) EOF() antlr.TerminalNode {
	return s.GetToken(CqlParserEOF, 0)
}

func (s *LibraryContext) LibraryDefinition() ILibraryDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryDefinitionContext)
}

func (s *LibraryContext) AllDefinition() []IDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IDefinitionContext); ok {
			tst[i] = t.(IDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) Definition(i int) IDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDefinitionContext)
}

func (s *LibraryContext) AllStatement() []IStatementContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IStatementContext); ok {
			len++
		}
	}

	tst := make([]IStatementContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IStatementContext); ok {
			tst[i] = t.(IStatementContext)
			i++
		}
	}

	return tst
}

func (s *LibraryContext) Statement(i int) IStatementContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStatementContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStatementContext)
}

func (s *LibraryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LibraryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLibrary(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Library() (localctx ILibraryContext) {
	localctx = NewLibraryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, CqlParserRULE_library)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(222)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__0 {
		{
			p.SetState(221)
			p.LibraryDefinition()
		}

	}
	p.SetState(227)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 1316328) != 0) {
		{
			p.SetState(224)
			p.Definition()
		}


		p.SetState(229)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(233)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__26 || _la == CqlParserT__27 {
		{
			p.SetState(230)
			p.Statement()
		}


		p.SetState(235)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(236)
		p.Match(CqlParserEOF)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILibraryDefinitionContext is an interface to support dynamic dispatch.
type ILibraryDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	VersionSpecifier() IVersionSpecifierContext

	// IsLibraryDefinitionContext differentiates from other interfaces.
	IsLibraryDefinitionContext()
}

type LibraryDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryDefinitionContext() *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_libraryDefinition
	return p
}

func InitEmptyLibraryDefinitionContext(p *LibraryDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_libraryDefinition
}

func (*LibraryDefinitionContext) IsLibraryDefinitionContext() {}

func NewLibraryDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryDefinitionContext {
	var p = new(LibraryDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_libraryDefinition

	return p
}

func (s *LibraryDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryDefinitionContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *LibraryDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *LibraryDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LibraryDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLibraryDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) LibraryDefinition() (localctx ILibraryDefinitionContext) {
	localctx = NewLibraryDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, CqlParserRULE_libraryDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(238)
		p.Match(CqlParserT__0)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(239)
		p.QualifiedIdentifier()
	}
	p.SetState(242)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__1 {
		{
			p.SetState(240)
			p.Match(CqlParserT__1)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(241)
			p.VersionSpecifier()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUsingDefinitionContext is an interface to support dynamic dispatch.
type IUsingDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	VersionSpecifier() IVersionSpecifierContext
	LocalIdentifier() ILocalIdentifierContext

	// IsUsingDefinitionContext differentiates from other interfaces.
	IsUsingDefinitionContext()
}

type UsingDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUsingDefinitionContext() *UsingDefinitionContext {
	var p = new(UsingDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingDefinition
	return p
}

func InitEmptyUsingDefinitionContext(p *UsingDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_usingDefinition
}

func (*UsingDefinitionContext) IsUsingDefinitionContext() {}

func NewUsingDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UsingDefinitionContext {
	var p = new(UsingDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_usingDefinition

	return p
}

func (s *UsingDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *UsingDefinitionContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *UsingDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *UsingDefinitionContext) LocalIdentifier() ILocalIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalIdentifierContext)
}

func (s *UsingDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UsingDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UsingDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitUsingDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) UsingDefinition() (localctx IUsingDefinitionContext) {
	localctx = NewUsingDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, CqlParserRULE_usingDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(244)
		p.Match(CqlParserT__2)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(245)
		p.QualifiedIdentifier()
	}
	p.SetState(248)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__1 {
		{
			p.SetState(246)
			p.Match(CqlParserT__1)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(247)
			p.VersionSpecifier()
		}

	}
	p.SetState(252)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__3 {
		{
			p.SetState(250)
			p.Match(CqlParserT__3)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(251)
			p.LocalIdentifier()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIncludeDefinitionContext is an interface to support dynamic dispatch.
type IIncludeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifier() IQualifiedIdentifierContext
	VersionSpecifier() IVersionSpecifierContext
	LocalIdentifier() ILocalIdentifierContext

	// IsIncludeDefinitionContext differentiates from other interfaces.
	IsIncludeDefinitionContext()
}

type IncludeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIncludeDefinitionContext() *IncludeDefinitionContext {
	var p = new(IncludeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_includeDefinition
	return p
}

func InitEmptyIncludeDefinitionContext(p *IncludeDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_includeDefinition
}

func (*IncludeDefinitionContext) IsIncludeDefinitionContext() {}

func NewIncludeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IncludeDefinitionContext {
	var p = new(IncludeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_includeDefinition

	return p
}

func (s *IncludeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *IncludeDefinitionContext) QualifiedIdentifier() IQualifiedIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierContext)
}

func (s *IncludeDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *IncludeDefinitionContext) LocalIdentifier() ILocalIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILocalIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILocalIdentifierContext)
}

func (s *IncludeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IncludeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIncludeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) IncludeDefinition() (localctx IIncludeDefinitionContext) {
	localctx = NewIncludeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, CqlParserRULE_includeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(254)
		p.Match(CqlParserT__4)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(255)
		p.QualifiedIdentifier()
	}
	p.SetState(258)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__1 {
		{
			p.SetState(256)
			p.Match(CqlParserT__1)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(257)
			p.VersionSpecifier()
		}

	}
	p.SetState(262)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__3 {
		{
			p.SetState(260)
			p.Match(CqlParserT__3)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(261)
			p.LocalIdentifier()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILocalIdentifierContext is an interface to support dynamic dispatch.
type ILocalIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLocalIdentifierContext differentiates from other interfaces.
	IsLocalIdentifierContext()
}

type LocalIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocalIdentifierContext() *LocalIdentifierContext {
	var p = new(LocalIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_localIdentifier
	return p
}

func InitEmptyLocalIdentifierContext(p *LocalIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_localIdentifier
}

func (*LocalIdentifierContext) IsLocalIdentifierContext() {}

func NewLocalIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LocalIdentifierContext {
	var p = new(LocalIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_localIdentifier

	return p
}

func (s *LocalIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LocalIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LocalIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LocalIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LocalIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLocalIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) LocalIdentifier() (localctx ILocalIdentifierContext) {
	localctx = NewLocalIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, CqlParserRULE_localIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(264)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAccessModifierContext is an interface to support dynamic dispatch.
type IAccessModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsAccessModifierContext differentiates from other interfaces.
	IsAccessModifierContext()
}

type AccessModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAccessModifierContext() *AccessModifierContext {
	var p = new(AccessModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_accessModifier
	return p
}

func InitEmptyAccessModifierContext(p *AccessModifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_accessModifier
}

func (*AccessModifierContext) IsAccessModifierContext() {}

func NewAccessModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AccessModifierContext {
	var p = new(AccessModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_accessModifier

	return p
}

func (s *AccessModifierContext) GetParser() antlr.Parser { return s.parser }
func (s *AccessModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AccessModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AccessModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAccessModifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) AccessModifier() (localctx IAccessModifierContext) {
	localctx = NewAccessModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, CqlParserRULE_accessModifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(266)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__5 || _la == CqlParserT__6) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParameterDefinitionContext is an interface to support dynamic dispatch.
type IParameterDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AccessModifier() IAccessModifierContext
	TypeSpecifier() ITypeSpecifierContext
	Expression() IExpressionContext

	// IsParameterDefinitionContext differentiates from other interfaces.
	IsParameterDefinitionContext()
}

type ParameterDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParameterDefinitionContext() *ParameterDefinitionContext {
	var p = new(ParameterDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_parameterDefinition
	return p
}

func InitEmptyParameterDefinitionContext(p *ParameterDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_parameterDefinition
}

func (*ParameterDefinitionContext) IsParameterDefinitionContext() {}

func NewParameterDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParameterDefinitionContext {
	var p = new(ParameterDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_parameterDefinition

	return p
}

func (s *ParameterDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ParameterDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ParameterDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ParameterDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ParameterDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParameterDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParameterDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParameterDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitParameterDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ParameterDefinition() (localctx IParameterDefinitionContext) {
	localctx = NewParameterDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, CqlParserRULE_parameterDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(269)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(268)
			p.AccessModifier()
		}

	}
	{
		p.SetState(271)
		p.Match(CqlParserT__7)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(272)
		p.Identifier()
	}
	p.SetState(274)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 10, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(273)
			p.TypeSpecifier()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(278)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__8 {
		{
			p.SetState(276)
			p.Match(CqlParserT__8)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(277)
			p.expression(0)
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodesystemDefinitionContext is an interface to support dynamic dispatch.
type ICodesystemDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CodesystemId() ICodesystemIdContext
	AccessModifier() IAccessModifierContext
	VersionSpecifier() IVersionSpecifierContext

	// IsCodesystemDefinitionContext differentiates from other interfaces.
	IsCodesystemDefinitionContext()
}

type CodesystemDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemDefinitionContext() *CodesystemDefinitionContext {
	var p = new(CodesystemDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemDefinition
	return p
}

func InitEmptyCodesystemDefinitionContext(p *CodesystemDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemDefinition
}

func (*CodesystemDefinitionContext) IsCodesystemDefinitionContext() {}

func NewCodesystemDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemDefinitionContext {
	var p = new(CodesystemDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codesystemDefinition

	return p
}

func (s *CodesystemDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodesystemDefinitionContext) CodesystemId() ICodesystemIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdContext)
}

func (s *CodesystemDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *CodesystemDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *CodesystemDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodesystemDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodesystemDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodesystemDefinition() (localctx ICodesystemDefinitionContext) {
	localctx = NewCodesystemDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, CqlParserRULE_codesystemDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(281)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(280)
			p.AccessModifier()
		}

	}
	{
		p.SetState(283)
		p.Match(CqlParserT__9)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(284)
		p.Identifier()
	}
	{
		p.SetState(285)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(286)
		p.CodesystemId()
	}
	p.SetState(289)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__1 {
		{
			p.SetState(287)
			p.Match(CqlParserT__1)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(288)
			p.VersionSpecifier()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesetDefinitionContext is an interface to support dynamic dispatch.
type IValuesetDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ValuesetId() IValuesetIdContext
	AccessModifier() IAccessModifierContext
	VersionSpecifier() IVersionSpecifierContext
	Codesystems() ICodesystemsContext

	// IsValuesetDefinitionContext differentiates from other interfaces.
	IsValuesetDefinitionContext()
}

type ValuesetDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesetDefinitionContext() *ValuesetDefinitionContext {
	var p = new(ValuesetDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_valuesetDefinition
	return p
}

func InitEmptyValuesetDefinitionContext(p *ValuesetDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_valuesetDefinition
}

func (*ValuesetDefinitionContext) IsValuesetDefinitionContext() {}

func NewValuesetDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesetDefinitionContext {
	var p = new(ValuesetDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_valuesetDefinition

	return p
}

func (s *ValuesetDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesetDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ValuesetDefinitionContext) ValuesetId() IValuesetIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IValuesetIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IValuesetIdContext)
}

func (s *ValuesetDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ValuesetDefinitionContext) VersionSpecifier() IVersionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IVersionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IVersionSpecifierContext)
}

func (s *ValuesetDefinitionContext) Codesystems() ICodesystemsContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemsContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemsContext)
}

func (s *ValuesetDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesetDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesetDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitValuesetDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ValuesetDefinition() (localctx IValuesetDefinitionContext) {
	localctx = NewValuesetDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, CqlParserRULE_valuesetDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(292)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(291)
			p.AccessModifier()
		}

	}
	{
		p.SetState(294)
		p.Match(CqlParserT__11)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(295)
		p.Identifier()
	}
	{
		p.SetState(296)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(297)
		p.ValuesetId()
	}
	p.SetState(300)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__1 {
		{
			p.SetState(298)
			p.Match(CqlParserT__1)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(299)
			p.VersionSpecifier()
		}

	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__12 {
		{
			p.SetState(302)
			p.Codesystems()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodesystemsContext is an interface to support dynamic dispatch.
type ICodesystemsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCodesystemIdentifier() []ICodesystemIdentifierContext
	CodesystemIdentifier(i int) ICodesystemIdentifierContext

	// IsCodesystemsContext differentiates from other interfaces.
	IsCodesystemsContext()
}

type CodesystemsContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemsContext() *CodesystemsContext {
	var p = new(CodesystemsContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystems
	return p
}

func InitEmptyCodesystemsContext(p *CodesystemsContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystems
}

func (*CodesystemsContext) IsCodesystemsContext() {}

func NewCodesystemsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemsContext {
	var p = new(CodesystemsContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codesystems

	return p
}

func (s *CodesystemsContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemsContext) AllCodesystemIdentifier() []ICodesystemIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ICodesystemIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodesystemIdentifierContext); ok {
			tst[i] = t.(ICodesystemIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *CodesystemsContext) CodesystemIdentifier(i int) ICodesystemIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodesystemsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodesystemsContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodesystems(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Codesystems() (localctx ICodesystemsContext) {
	localctx = NewCodesystemsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, CqlParserRULE_codesystems)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(305)
		p.Match(CqlParserT__12)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(306)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(307)
		p.CodesystemIdentifier()
	}
	p.SetState(312)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(308)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(309)
			p.CodesystemIdentifier()
		}


		p.SetState(314)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(315)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodesystemIdentifierContext is an interface to support dynamic dispatch.
type ICodesystemIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LibraryIdentifier() ILibraryIdentifierContext

	// IsCodesystemIdentifierContext differentiates from other interfaces.
	IsCodesystemIdentifierContext()
}

type CodesystemIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemIdentifierContext() *CodesystemIdentifierContext {
	var p = new(CodesystemIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemIdentifier
	return p
}

func InitEmptyCodesystemIdentifierContext(p *CodesystemIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemIdentifier
}

func (*CodesystemIdentifierContext) IsCodesystemIdentifierContext() {}

func NewCodesystemIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemIdentifierContext {
	var p = new(CodesystemIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codesystemIdentifier

	return p
}

func (s *CodesystemIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodesystemIdentifierContext) LibraryIdentifier() ILibraryIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIdentifierContext)
}

func (s *CodesystemIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodesystemIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodesystemIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodesystemIdentifier() (localctx ICodesystemIdentifierContext) {
	localctx = NewCodesystemIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, CqlParserRULE_codesystemIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(320)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(317)
			p.LibraryIdentifier()
		}
		{
			p.SetState(318)
			p.Match(CqlParserT__16)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(322)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILibraryIdentifierContext is an interface to support dynamic dispatch.
type ILibraryIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsLibraryIdentifierContext differentiates from other interfaces.
	IsLibraryIdentifierContext()
}

type LibraryIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLibraryIdentifierContext() *LibraryIdentifierContext {
	var p = new(LibraryIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_libraryIdentifier
	return p
}

func InitEmptyLibraryIdentifierContext(p *LibraryIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_libraryIdentifier
}

func (*LibraryIdentifierContext) IsLibraryIdentifierContext() {}

func NewLibraryIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LibraryIdentifierContext {
	var p = new(LibraryIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_libraryIdentifier

	return p
}

func (s *LibraryIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *LibraryIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LibraryIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LibraryIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LibraryIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLibraryIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) LibraryIdentifier() (localctx ILibraryIdentifierContext) {
	localctx = NewLibraryIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, CqlParserRULE_libraryIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(324)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodeDefinitionContext is an interface to support dynamic dispatch.
type ICodeDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	CodeId() ICodeIdContext
	CodesystemIdentifier() ICodesystemIdentifierContext
	AccessModifier() IAccessModifierContext
	DisplayClause() IDisplayClauseContext

	// IsCodeDefinitionContext differentiates from other interfaces.
	IsCodeDefinitionContext()
}

type CodeDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeDefinitionContext() *CodeDefinitionContext {
	var p = new(CodeDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeDefinition
	return p
}

func InitEmptyCodeDefinitionContext(p *CodeDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeDefinition
}

func (*CodeDefinitionContext) IsCodeDefinitionContext() {}

func NewCodeDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeDefinitionContext {
	var p = new(CodeDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeDefinition

	return p
}

func (s *CodeDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodeDefinitionContext) CodeId() ICodeIdContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeIdContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeIdContext)
}

func (s *CodeDefinitionContext) CodesystemIdentifier() ICodesystemIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodeDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *CodeDefinitionContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *CodeDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodeDefinition() (localctx ICodeDefinitionContext) {
	localctx = NewCodeDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, CqlParserRULE_codeDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(327)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(326)
			p.AccessModifier()
		}

	}
	{
		p.SetState(329)
		p.Match(CqlParserT__17)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(330)
		p.Identifier()
	}
	{
		p.SetState(331)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(332)
		p.CodeId()
	}
	{
		p.SetState(333)
		p.Match(CqlParserT__18)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(334)
		p.CodesystemIdentifier()
	}
	p.SetState(336)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__153 {
		{
			p.SetState(335)
			p.DisplayClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConceptDefinitionContext is an interface to support dynamic dispatch.
type IConceptDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllCodeIdentifier() []ICodeIdentifierContext
	CodeIdentifier(i int) ICodeIdentifierContext
	AccessModifier() IAccessModifierContext
	DisplayClause() IDisplayClauseContext

	// IsConceptDefinitionContext differentiates from other interfaces.
	IsConceptDefinitionContext()
}

type ConceptDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptDefinitionContext() *ConceptDefinitionContext {
	var p = new(ConceptDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_conceptDefinition
	return p
}

func InitEmptyConceptDefinitionContext(p *ConceptDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_conceptDefinition
}

func (*ConceptDefinitionContext) IsConceptDefinitionContext() {}

func NewConceptDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptDefinitionContext {
	var p = new(ConceptDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_conceptDefinition

	return p
}

func (s *ConceptDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ConceptDefinitionContext) AllCodeIdentifier() []ICodeIdentifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeIdentifierContext); ok {
			len++
		}
	}

	tst := make([]ICodeIdentifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeIdentifierContext); ok {
			tst[i] = t.(ICodeIdentifierContext)
			i++
		}
	}

	return tst
}

func (s *ConceptDefinitionContext) CodeIdentifier(i int) ICodeIdentifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeIdentifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeIdentifierContext)
}

func (s *ConceptDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ConceptDefinitionContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *ConceptDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConceptDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitConceptDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ConceptDefinition() (localctx IConceptDefinitionContext) {
	localctx = NewConceptDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, CqlParserRULE_conceptDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(339)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(338)
			p.AccessModifier()
		}

	}
	{
		p.SetState(341)
		p.Match(CqlParserT__19)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(342)
		p.Identifier()
	}
	{
		p.SetState(343)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(344)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(345)
		p.CodeIdentifier()
	}
	p.SetState(350)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(346)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(347)
			p.CodeIdentifier()
		}


		p.SetState(352)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(353)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(355)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__153 {
		{
			p.SetState(354)
			p.DisplayClause()
		}

	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodeIdentifierContext is an interface to support dynamic dispatch.
type ICodeIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	LibraryIdentifier() ILibraryIdentifierContext

	// IsCodeIdentifierContext differentiates from other interfaces.
	IsCodeIdentifierContext()
}

type CodeIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeIdentifierContext() *CodeIdentifierContext {
	var p = new(CodeIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeIdentifier
	return p
}

func InitEmptyCodeIdentifierContext(p *CodeIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeIdentifier
}

func (*CodeIdentifierContext) IsCodeIdentifierContext() {}

func NewCodeIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeIdentifierContext {
	var p = new(CodeIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeIdentifier

	return p
}

func (s *CodeIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *CodeIdentifierContext) LibraryIdentifier() ILibraryIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILibraryIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILibraryIdentifierContext)
}

func (s *CodeIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodeIdentifier() (localctx ICodeIdentifierContext) {
	localctx = NewCodeIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, CqlParserRULE_codeIdentifier)
	p.EnterOuterAlt(localctx, 1)
	p.SetState(360)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(357)
			p.LibraryIdentifier()
		}
		{
			p.SetState(358)
			p.Match(CqlParserT__16)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(362)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodesystemIdContext is an interface to support dynamic dispatch.
type ICodesystemIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsCodesystemIdContext differentiates from other interfaces.
	IsCodesystemIdContext()
}

type CodesystemIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodesystemIdContext() *CodesystemIdContext {
	var p = new(CodesystemIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemId
	return p
}

func InitEmptyCodesystemIdContext(p *CodesystemIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codesystemId
}

func (*CodesystemIdContext) IsCodesystemIdContext() {}

func NewCodesystemIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodesystemIdContext {
	var p = new(CodesystemIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codesystemId

	return p
}

func (s *CodesystemIdContext) GetParser() antlr.Parser { return s.parser }

func (s *CodesystemIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *CodesystemIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodesystemIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodesystemIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodesystemId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodesystemId() (localctx ICodesystemIdContext) {
	localctx = NewCodesystemIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, CqlParserRULE_codesystemId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(364)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IValuesetIdContext is an interface to support dynamic dispatch.
type IValuesetIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsValuesetIdContext differentiates from other interfaces.
	IsValuesetIdContext()
}

type ValuesetIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyValuesetIdContext() *ValuesetIdContext {
	var p = new(ValuesetIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_valuesetId
	return p
}

func InitEmptyValuesetIdContext(p *ValuesetIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_valuesetId
}

func (*ValuesetIdContext) IsValuesetIdContext() {}

func NewValuesetIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ValuesetIdContext {
	var p = new(ValuesetIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_valuesetId

	return p
}

func (s *ValuesetIdContext) GetParser() antlr.Parser { return s.parser }

func (s *ValuesetIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *ValuesetIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ValuesetIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ValuesetIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitValuesetId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ValuesetId() (localctx IValuesetIdContext) {
	localctx = NewValuesetIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, CqlParserRULE_valuesetId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(366)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IVersionSpecifierContext is an interface to support dynamic dispatch.
type IVersionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsVersionSpecifierContext differentiates from other interfaces.
	IsVersionSpecifierContext()
}

type VersionSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVersionSpecifierContext() *VersionSpecifierContext {
	var p = new(VersionSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_versionSpecifier
	return p
}

func InitEmptyVersionSpecifierContext(p *VersionSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_versionSpecifier
}

func (*VersionSpecifierContext) IsVersionSpecifierContext() {}

func NewVersionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VersionSpecifierContext {
	var p = new(VersionSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_versionSpecifier

	return p
}

func (s *VersionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *VersionSpecifierContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *VersionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VersionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *VersionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitVersionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) VersionSpecifier() (localctx IVersionSpecifierContext) {
	localctx = NewVersionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, CqlParserRULE_versionSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(368)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodeIdContext is an interface to support dynamic dispatch.
type ICodeIdContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsCodeIdContext differentiates from other interfaces.
	IsCodeIdContext()
}

type CodeIdContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeIdContext() *CodeIdContext {
	var p = new(CodeIdContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeId
	return p
}

func InitEmptyCodeIdContext(p *CodeIdContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeId
}

func (*CodeIdContext) IsCodeIdContext() {}

func NewCodeIdContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeIdContext {
	var p = new(CodeIdContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeId

	return p
}

func (s *CodeIdContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeIdContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *CodeIdContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeIdContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeIdContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeId(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodeId() (localctx ICodeIdContext) {
	localctx = NewCodeIdContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, CqlParserRULE_codeId)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(370)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeSpecifierContext is an interface to support dynamic dispatch.
type ITypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	ListTypeSpecifier() IListTypeSpecifierContext
	IntervalTypeSpecifier() IIntervalTypeSpecifierContext
	TupleTypeSpecifier() ITupleTypeSpecifierContext
	ChoiceTypeSpecifier() IChoiceTypeSpecifierContext

	// IsTypeSpecifierContext differentiates from other interfaces.
	IsTypeSpecifierContext()
}

type TypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeSpecifierContext() *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeSpecifier
	return p
}

func InitEmptyTypeSpecifierContext(p *TypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeSpecifier
}

func (*TypeSpecifierContext) IsTypeSpecifierContext() {}

func NewTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeSpecifierContext {
	var p = new(TypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_typeSpecifier

	return p
}

func (s *TypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TypeSpecifierContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *TypeSpecifierContext) ListTypeSpecifier() IListTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListTypeSpecifierContext)
}

func (s *TypeSpecifierContext) IntervalTypeSpecifier() IIntervalTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalTypeSpecifierContext)
}

func (s *TypeSpecifierContext) TupleTypeSpecifier() ITupleTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleTypeSpecifierContext)
}

func (s *TypeSpecifierContext) ChoiceTypeSpecifier() IChoiceTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IChoiceTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IChoiceTypeSpecifierContext)
}

func (s *TypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TypeSpecifier() (localctx ITypeSpecifierContext) {
	localctx = NewTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, CqlParserRULE_typeSpecifier)
	p.SetState(377)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserT__154, CqlParserT__155, CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(372)
			p.NamedTypeSpecifier()
		}


	case CqlParserT__20:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(373)
			p.ListTypeSpecifier()
		}


	case CqlParserT__23:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(374)
			p.IntervalTypeSpecifier()
		}


	case CqlParserT__24:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(375)
			p.TupleTypeSpecifier()
		}


	case CqlParserT__25:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(376)
			p.ChoiceTypeSpecifier()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// INamedTypeSpecifierContext is an interface to support dynamic dispatch.
type INamedTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialOrTypeNameIdentifier() IReferentialOrTypeNameIdentifierContext
	AllQualifier() []IQualifierContext
	Qualifier(i int) IQualifierContext

	// IsNamedTypeSpecifierContext differentiates from other interfaces.
	IsNamedTypeSpecifierContext()
}

type NamedTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyNamedTypeSpecifierContext() *NamedTypeSpecifierContext {
	var p = new(NamedTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_namedTypeSpecifier
	return p
}

func InitEmptyNamedTypeSpecifierContext(p *NamedTypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_namedTypeSpecifier
}

func (*NamedTypeSpecifierContext) IsNamedTypeSpecifierContext() {}

func NewNamedTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *NamedTypeSpecifierContext {
	var p = new(NamedTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_namedTypeSpecifier

	return p
}

func (s *NamedTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *NamedTypeSpecifierContext) ReferentialOrTypeNameIdentifier() IReferentialOrTypeNameIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialOrTypeNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialOrTypeNameIdentifierContext)
}

func (s *NamedTypeSpecifierContext) AllQualifier() []IQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierContext); ok {
			len++
		}
	}

	tst := make([]IQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierContext); ok {
			tst[i] = t.(IQualifierContext)
			i++
		}
	}

	return tst
}

func (s *NamedTypeSpecifierContext) Qualifier(i int) IQualifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierContext)
}

func (s *NamedTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NamedTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *NamedTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitNamedTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) NamedTypeSpecifier() (localctx INamedTypeSpecifierContext) {
	localctx = NewNamedTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, CqlParserRULE_namedTypeSpecifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(384)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(379)
				p.Qualifier()
			}
			{
				p.SetState(380)
				p.Match(CqlParserT__16)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(386)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 26, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(387)
		p.ReferentialOrTypeNameIdentifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IModelIdentifierContext is an interface to support dynamic dispatch.
type IModelIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsModelIdentifierContext differentiates from other interfaces.
	IsModelIdentifierContext()
}

type ModelIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyModelIdentifierContext() *ModelIdentifierContext {
	var p = new(ModelIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_modelIdentifier
	return p
}

func InitEmptyModelIdentifierContext(p *ModelIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_modelIdentifier
}

func (*ModelIdentifierContext) IsModelIdentifierContext() {}

func NewModelIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ModelIdentifierContext {
	var p = new(ModelIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_modelIdentifier

	return p
}

func (s *ModelIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ModelIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ModelIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ModelIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ModelIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitModelIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ModelIdentifier() (localctx IModelIdentifierContext) {
	localctx = NewModelIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, CqlParserRULE_modelIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(389)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IListTypeSpecifierContext is an interface to support dynamic dispatch.
type IListTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifier() ITypeSpecifierContext

	// IsListTypeSpecifierContext differentiates from other interfaces.
	IsListTypeSpecifierContext()
}

type ListTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListTypeSpecifierContext() *ListTypeSpecifierContext {
	var p = new(ListTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listTypeSpecifier
	return p
}

func InitEmptyListTypeSpecifierContext(p *ListTypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listTypeSpecifier
}

func (*ListTypeSpecifierContext) IsListTypeSpecifierContext() {}

func NewListTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListTypeSpecifierContext {
	var p = new(ListTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listTypeSpecifier

	return p
}

func (s *ListTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ListTypeSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ListTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ListTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitListTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ListTypeSpecifier() (localctx IListTypeSpecifierContext) {
	localctx = NewListTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, CqlParserRULE_listTypeSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(391)
		p.Match(CqlParserT__20)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(392)
		p.Match(CqlParserT__21)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(393)
		p.TypeSpecifier()
	}
	{
		p.SetState(394)
		p.Match(CqlParserT__22)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalTypeSpecifierContext is an interface to support dynamic dispatch.
type IIntervalTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	TypeSpecifier() ITypeSpecifierContext

	// IsIntervalTypeSpecifierContext differentiates from other interfaces.
	IsIntervalTypeSpecifierContext()
}

type IntervalTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalTypeSpecifierContext() *IntervalTypeSpecifierContext {
	var p = new(IntervalTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalTypeSpecifier
	return p
}

func InitEmptyIntervalTypeSpecifierContext(p *IntervalTypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalTypeSpecifier
}

func (*IntervalTypeSpecifierContext) IsIntervalTypeSpecifierContext() {}

func NewIntervalTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalTypeSpecifierContext {
	var p = new(IntervalTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_intervalTypeSpecifier

	return p
}

func (s *IntervalTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalTypeSpecifierContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *IntervalTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIntervalTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) IntervalTypeSpecifier() (localctx IIntervalTypeSpecifierContext) {
	localctx = NewIntervalTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, CqlParserRULE_intervalTypeSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(396)
		p.Match(CqlParserT__23)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(397)
		p.Match(CqlParserT__21)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(398)
		p.TypeSpecifier()
	}
	{
		p.SetState(399)
		p.Match(CqlParserT__22)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITupleTypeSpecifierContext is an interface to support dynamic dispatch.
type ITupleTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTupleElementDefinition() []ITupleElementDefinitionContext
	TupleElementDefinition(i int) ITupleElementDefinitionContext

	// IsTupleTypeSpecifierContext differentiates from other interfaces.
	IsTupleTypeSpecifierContext()
}

type TupleTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleTypeSpecifierContext() *TupleTypeSpecifierContext {
	var p = new(TupleTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleTypeSpecifier
	return p
}

func InitEmptyTupleTypeSpecifierContext(p *TupleTypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleTypeSpecifier
}

func (*TupleTypeSpecifierContext) IsTupleTypeSpecifierContext() {}

func NewTupleTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleTypeSpecifierContext {
	var p = new(TupleTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tupleTypeSpecifier

	return p
}

func (s *TupleTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleTypeSpecifierContext) AllTupleElementDefinition() []ITupleElementDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleElementDefinitionContext); ok {
			len++
		}
	}

	tst := make([]ITupleElementDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleElementDefinitionContext); ok {
			tst[i] = t.(ITupleElementDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *TupleTypeSpecifierContext) TupleElementDefinition(i int) ITupleElementDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementDefinitionContext)
}

func (s *TupleTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TupleTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTupleTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TupleTypeSpecifier() (localctx ITupleTypeSpecifierContext) {
	localctx = NewTupleTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, CqlParserRULE_tupleTypeSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(401)
		p.Match(CqlParserT__24)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(402)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(403)
		p.TupleElementDefinition()
	}
	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(404)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(405)
			p.TupleElementDefinition()
		}


		p.SetState(410)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(411)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITupleElementDefinitionContext is an interface to support dynamic dispatch.
type ITupleElementDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeSpecifier() ITypeSpecifierContext

	// IsTupleElementDefinitionContext differentiates from other interfaces.
	IsTupleElementDefinitionContext()
}

type TupleElementDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementDefinitionContext() *TupleElementDefinitionContext {
	var p = new(TupleElementDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleElementDefinition
	return p
}

func InitEmptyTupleElementDefinitionContext(p *TupleElementDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleElementDefinition
}

func (*TupleElementDefinitionContext) IsTupleElementDefinitionContext() {}

func NewTupleElementDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementDefinitionContext {
	var p = new(TupleElementDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tupleElementDefinition

	return p
}

func (s *TupleElementDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementDefinitionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *TupleElementDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *TupleElementDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TupleElementDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTupleElementDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TupleElementDefinition() (localctx ITupleElementDefinitionContext) {
	localctx = NewTupleElementDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, CqlParserRULE_tupleElementDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(413)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(414)
		p.TypeSpecifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IChoiceTypeSpecifierContext is an interface to support dynamic dispatch.
type IChoiceTypeSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTypeSpecifier() []ITypeSpecifierContext
	TypeSpecifier(i int) ITypeSpecifierContext

	// IsChoiceTypeSpecifierContext differentiates from other interfaces.
	IsChoiceTypeSpecifierContext()
}

type ChoiceTypeSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChoiceTypeSpecifierContext() *ChoiceTypeSpecifierContext {
	var p = new(ChoiceTypeSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_choiceTypeSpecifier
	return p
}

func InitEmptyChoiceTypeSpecifierContext(p *ChoiceTypeSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_choiceTypeSpecifier
}

func (*ChoiceTypeSpecifierContext) IsChoiceTypeSpecifierContext() {}

func NewChoiceTypeSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ChoiceTypeSpecifierContext {
	var p = new(ChoiceTypeSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_choiceTypeSpecifier

	return p
}

func (s *ChoiceTypeSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ChoiceTypeSpecifierContext) AllTypeSpecifier() []ITypeSpecifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			len++
		}
	}

	tst := make([]ITypeSpecifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITypeSpecifierContext); ok {
			tst[i] = t.(ITypeSpecifierContext)
			i++
		}
	}

	return tst
}

func (s *ChoiceTypeSpecifierContext) TypeSpecifier(i int) ITypeSpecifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ChoiceTypeSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ChoiceTypeSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ChoiceTypeSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitChoiceTypeSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ChoiceTypeSpecifier() (localctx IChoiceTypeSpecifierContext) {
	localctx = NewChoiceTypeSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, CqlParserRULE_choiceTypeSpecifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(416)
		p.Match(CqlParserT__25)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(417)
		p.Match(CqlParserT__21)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(418)
		p.TypeSpecifier()
	}
	p.SetState(423)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(419)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(420)
			p.TypeSpecifier()
		}


		p.SetState(425)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(426)
		p.Match(CqlParserT__22)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStatementContext is an interface to support dynamic dispatch.
type IStatementContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionDefinition() IExpressionDefinitionContext
	ContextDefinition() IContextDefinitionContext
	FunctionDefinition() IFunctionDefinitionContext

	// IsStatementContext differentiates from other interfaces.
	IsStatementContext()
}

type StatementContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStatementContext() *StatementContext {
	var p = new(StatementContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_statement
	return p
}

func InitEmptyStatementContext(p *StatementContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_statement
}

func (*StatementContext) IsStatementContext() {}

func NewStatementContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StatementContext {
	var p = new(StatementContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_statement

	return p
}

func (s *StatementContext) GetParser() antlr.Parser { return s.parser }

func (s *StatementContext) ExpressionDefinition() IExpressionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionDefinitionContext)
}

func (s *StatementContext) ContextDefinition() IContextDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextDefinitionContext)
}

func (s *StatementContext) FunctionDefinition() IFunctionDefinitionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionDefinitionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionDefinitionContext)
}

func (s *StatementContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StatementContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StatementContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitStatement(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Statement() (localctx IStatementContext) {
	localctx = NewStatementContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, CqlParserRULE_statement)
	p.SetState(431)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 29, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(428)
			p.ExpressionDefinition()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(429)
			p.ContextDefinition()
		}


	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(430)
			p.FunctionDefinition()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionDefinitionContext is an interface to support dynamic dispatch.
type IExpressionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext
	AccessModifier() IAccessModifierContext

	// IsExpressionDefinitionContext differentiates from other interfaces.
	IsExpressionDefinitionContext()
}

type ExpressionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionDefinitionContext() *ExpressionDefinitionContext {
	var p = new(ExpressionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionDefinition
	return p
}

func InitEmptyExpressionDefinitionContext(p *ExpressionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionDefinition
}

func (*ExpressionDefinitionContext) IsExpressionDefinitionContext() {}

func NewExpressionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionDefinitionContext {
	var p = new(ExpressionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_expressionDefinition

	return p
}

func (s *ExpressionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExpressionDefinitionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ExpressionDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *ExpressionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExpressionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitExpressionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ExpressionDefinition() (localctx IExpressionDefinitionContext) {
	localctx = NewExpressionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, CqlParserRULE_expressionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(433)
		p.Match(CqlParserT__26)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(435)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(434)
			p.AccessModifier()
		}

	}
	{
		p.SetState(437)
		p.Identifier()
	}
	{
		p.SetState(438)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(439)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IContextDefinitionContext is an interface to support dynamic dispatch.
type IContextDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	ModelIdentifier() IModelIdentifierContext

	// IsContextDefinitionContext differentiates from other interfaces.
	IsContextDefinitionContext()
}

type ContextDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextDefinitionContext() *ContextDefinitionContext {
	var p = new(ContextDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_contextDefinition
	return p
}

func InitEmptyContextDefinitionContext(p *ContextDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_contextDefinition
}

func (*ContextDefinitionContext) IsContextDefinitionContext() {}

func NewContextDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextDefinitionContext {
	var p = new(ContextDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_contextDefinition

	return p
}

func (s *ContextDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextDefinitionContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ContextDefinitionContext) ModelIdentifier() IModelIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IModelIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IModelIdentifierContext)
}

func (s *ContextDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContextDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitContextDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ContextDefinition() (localctx IContextDefinitionContext) {
	localctx = NewContextDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, CqlParserRULE_contextDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(441)
		p.Match(CqlParserT__27)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(445)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(442)
			p.ModelIdentifier()
		}
		{
			p.SetState(443)
			p.Match(CqlParserT__16)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(447)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFluentModifierContext is an interface to support dynamic dispatch.
type IFluentModifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFluentModifierContext differentiates from other interfaces.
	IsFluentModifierContext()
}

type FluentModifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFluentModifierContext() *FluentModifierContext {
	var p = new(FluentModifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fluentModifier
	return p
}

func InitEmptyFluentModifierContext(p *FluentModifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_fluentModifier
}

func (*FluentModifierContext) IsFluentModifierContext() {}

func NewFluentModifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FluentModifierContext {
	var p = new(FluentModifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_fluentModifier

	return p
}

func (s *FluentModifierContext) GetParser() antlr.Parser { return s.parser }
func (s *FluentModifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FluentModifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FluentModifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFluentModifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) FluentModifier() (localctx IFluentModifierContext) {
	localctx = NewFluentModifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, CqlParserRULE_fluentModifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(449)
		p.Match(CqlParserT__28)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionDefinitionContext is an interface to support dynamic dispatch.
type IFunctionDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext
	FunctionBody() IFunctionBodyContext
	AccessModifier() IAccessModifierContext
	FluentModifier() IFluentModifierContext
	AllOperandDefinition() []IOperandDefinitionContext
	OperandDefinition(i int) IOperandDefinitionContext
	TypeSpecifier() ITypeSpecifierContext

	// IsFunctionDefinitionContext differentiates from other interfaces.
	IsFunctionDefinitionContext()
}

type FunctionDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionDefinitionContext() *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionDefinition
	return p
}

func InitEmptyFunctionDefinitionContext(p *FunctionDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionDefinition
}

func (*FunctionDefinitionContext) IsFunctionDefinitionContext() {}

func NewFunctionDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionDefinitionContext {
	var p = new(FunctionDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_functionDefinition

	return p
}

func (s *FunctionDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionDefinitionContext) IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrFunctionIdentifierContext)
}

func (s *FunctionDefinitionContext) FunctionBody() IFunctionBodyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionBodyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionBodyContext)
}

func (s *FunctionDefinitionContext) AccessModifier() IAccessModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAccessModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAccessModifierContext)
}

func (s *FunctionDefinitionContext) FluentModifier() IFluentModifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFluentModifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFluentModifierContext)
}

func (s *FunctionDefinitionContext) AllOperandDefinition() []IOperandDefinitionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IOperandDefinitionContext); ok {
			len++
		}
	}

	tst := make([]IOperandDefinitionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IOperandDefinitionContext); ok {
			tst[i] = t.(IOperandDefinitionContext)
			i++
		}
	}

	return tst
}

func (s *FunctionDefinitionContext) OperandDefinition(i int) IOperandDefinitionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOperandDefinitionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOperandDefinitionContext)
}

func (s *FunctionDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *FunctionDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFunctionDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) FunctionDefinition() (localctx IFunctionDefinitionContext) {
	localctx = NewFunctionDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, CqlParserRULE_functionDefinition)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(451)
		p.Match(CqlParserT__26)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(453)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__5 || _la == CqlParserT__6 {
		{
			p.SetState(452)
			p.AccessModifier()
		}

	}
	p.SetState(456)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__28 {
		{
			p.SetState(455)
			p.FluentModifier()
		}

	}
	{
		p.SetState(458)
		p.Match(CqlParserT__29)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(459)
		p.IdentifierOrFunctionIdentifier()
	}
	{
		p.SetState(460)
		p.Match(CqlParserT__30)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(469)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 140772674742007806) != 0) || ((int64((_la - 74)) & ^0x3f) == 0 && ((int64(1) << (_la - 74)) & 2161833627658158317) != 0) || ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 12722963) != 0) {
		{
			p.SetState(461)
			p.OperandDefinition()
		}
		p.SetState(466)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == CqlParserT__14 {
			{
				p.SetState(462)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(463)
				p.OperandDefinition()
			}


			p.SetState(468)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(471)
		p.Match(CqlParserT__31)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(474)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__32 {
		{
			p.SetState(472)
			p.Match(CqlParserT__32)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(473)
			p.TypeSpecifier()
		}

	}
	{
		p.SetState(476)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(479)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__13, CqlParserT__17, CqlParserT__18, CqlParserT__19, CqlParserT__20, CqlParserT__23, CqlParserT__24, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__30, CqlParserT__37, CqlParserT__44, CqlParserT__47, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__57, CqlParserT__58, CqlParserT__59, CqlParserT__60, CqlParserT__62, CqlParserT__63, CqlParserT__67, CqlParserT__68, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__81, CqlParserT__82, CqlParserT__83, CqlParserT__84, CqlParserT__85, CqlParserT__86, CqlParserT__87, CqlParserT__88, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__93, CqlParserT__94, CqlParserT__95, CqlParserT__96, CqlParserT__97, CqlParserT__98, CqlParserT__99, CqlParserT__100, CqlParserT__101, CqlParserT__103, CqlParserT__104, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__111, CqlParserT__112, CqlParserT__113, CqlParserT__114, CqlParserT__118, CqlParserT__119, CqlParserT__121, CqlParserT__124, CqlParserT__125, CqlParserT__126, CqlParserT__127, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__150, CqlParserT__151, CqlParserT__152, CqlParserT__153, CqlParserT__154, CqlParserT__155, CqlParserT__156, CqlParserQUOTEDIDENTIFIER, CqlParserDATETIME, CqlParserLONGNUMBER, CqlParserDATE, CqlParserTIME, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER, CqlParserSTRING, CqlParserNUMBER:
		{
			p.SetState(477)
			p.FunctionBody()
		}


	case CqlParserT__33:
		{
			p.SetState(478)
			p.Match(CqlParserT__33)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOperandDefinitionContext is an interface to support dynamic dispatch.
type IOperandDefinitionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeSpecifier() ITypeSpecifierContext

	// IsOperandDefinitionContext differentiates from other interfaces.
	IsOperandDefinitionContext()
}

type OperandDefinitionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOperandDefinitionContext() *OperandDefinitionContext {
	var p = new(OperandDefinitionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_operandDefinition
	return p
}

func InitEmptyOperandDefinitionContext(p *OperandDefinitionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_operandDefinition
}

func (*OperandDefinitionContext) IsOperandDefinitionContext() {}

func NewOperandDefinitionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OperandDefinitionContext {
	var p = new(OperandDefinitionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_operandDefinition

	return p
}

func (s *OperandDefinitionContext) GetParser() antlr.Parser { return s.parser }

func (s *OperandDefinitionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *OperandDefinitionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *OperandDefinitionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OperandDefinitionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OperandDefinitionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitOperandDefinition(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) OperandDefinition() (localctx IOperandDefinitionContext) {
	localctx = NewOperandDefinitionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, CqlParserRULE_operandDefinition)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(481)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(482)
		p.TypeSpecifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionBodyContext is an interface to support dynamic dispatch.
type IFunctionBodyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsFunctionBodyContext differentiates from other interfaces.
	IsFunctionBodyContext()
}

type FunctionBodyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionBodyContext() *FunctionBodyContext {
	var p = new(FunctionBodyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionBody
	return p
}

func InitEmptyFunctionBodyContext(p *FunctionBodyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionBody
}

func (*FunctionBodyContext) IsFunctionBodyContext() {}

func NewFunctionBodyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionBodyContext {
	var p = new(FunctionBodyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_functionBody

	return p
}

func (s *FunctionBodyContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionBodyContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *FunctionBodyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionBodyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionBodyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFunctionBody(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) FunctionBody() (localctx IFunctionBodyContext) {
	localctx = NewFunctionBodyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, CqlParserRULE_functionBody)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(484)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuerySourceContext is an interface to support dynamic dispatch.
type IQuerySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Retrieve() IRetrieveContext
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext
	Expression() IExpressionContext

	// IsQuerySourceContext differentiates from other interfaces.
	IsQuerySourceContext()
}

type QuerySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuerySourceContext() *QuerySourceContext {
	var p = new(QuerySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_querySource
	return p
}

func InitEmptyQuerySourceContext(p *QuerySourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_querySource
}

func (*QuerySourceContext) IsQuerySourceContext() {}

func NewQuerySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuerySourceContext {
	var p = new(QuerySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_querySource

	return p
}

func (s *QuerySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *QuerySourceContext) Retrieve() IRetrieveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetrieveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetrieveContext)
}

func (s *QuerySourceContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *QuerySourceContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *QuerySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuerySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuerySourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQuerySource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QuerySource() (localctx IQuerySourceContext) {
	localctx = NewQuerySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, CqlParserRULE_querySource)
	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__37:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(486)
			p.Retrieve()
		}


	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(487)
			p.QualifiedIdentifierExpression()
		}


	case CqlParserT__30:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(488)
			p.Match(CqlParserT__30)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(489)
			p.expression(0)
		}
		{
			p.SetState(490)
			p.Match(CqlParserT__31)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAliasedQuerySourceContext is an interface to support dynamic dispatch.
type IAliasedQuerySourceContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QuerySource() IQuerySourceContext
	Alias() IAliasContext

	// IsAliasedQuerySourceContext differentiates from other interfaces.
	IsAliasedQuerySourceContext()
}

type AliasedQuerySourceContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasedQuerySourceContext() *AliasedQuerySourceContext {
	var p = new(AliasedQuerySourceContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aliasedQuerySource
	return p
}

func InitEmptyAliasedQuerySourceContext(p *AliasedQuerySourceContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aliasedQuerySource
}

func (*AliasedQuerySourceContext) IsAliasedQuerySourceContext() {}

func NewAliasedQuerySourceContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasedQuerySourceContext {
	var p = new(AliasedQuerySourceContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_aliasedQuerySource

	return p
}

func (s *AliasedQuerySourceContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasedQuerySourceContext) QuerySource() IQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuerySourceContext)
}

func (s *AliasedQuerySourceContext) Alias() IAliasContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasContext)
}

func (s *AliasedQuerySourceContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasedQuerySourceContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AliasedQuerySourceContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAliasedQuerySource(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) AliasedQuerySource() (localctx IAliasedQuerySourceContext) {
	localctx = NewAliasedQuerySourceContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, CqlParserRULE_aliasedQuerySource)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.QuerySource()
	}
	{
		p.SetState(495)
		p.Alias()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAliasContext is an interface to support dynamic dispatch.
type IAliasContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsAliasContext differentiates from other interfaces.
	IsAliasContext()
}

type AliasContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAliasContext() *AliasContext {
	var p = new(AliasContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alias
	return p
}

func InitEmptyAliasContext(p *AliasContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_alias
}

func (*AliasContext) IsAliasContext() {}

func NewAliasContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AliasContext {
	var p = new(AliasContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_alias

	return p
}

func (s *AliasContext) GetParser() antlr.Parser { return s.parser }

func (s *AliasContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AliasContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AliasContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AliasContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAlias(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Alias() (localctx IAliasContext) {
	localctx = NewAliasContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, CqlParserRULE_alias)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryInclusionClauseContext is an interface to support dynamic dispatch.
type IQueryInclusionClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	WithClause() IWithClauseContext
	WithoutClause() IWithoutClauseContext

	// IsQueryInclusionClauseContext differentiates from other interfaces.
	IsQueryInclusionClauseContext()
}

type QueryInclusionClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryInclusionClauseContext() *QueryInclusionClauseContext {
	var p = new(QueryInclusionClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_queryInclusionClause
	return p
}

func InitEmptyQueryInclusionClauseContext(p *QueryInclusionClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_queryInclusionClause
}

func (*QueryInclusionClauseContext) IsQueryInclusionClauseContext() {}

func NewQueryInclusionClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryInclusionClauseContext {
	var p = new(QueryInclusionClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_queryInclusionClause

	return p
}

func (s *QueryInclusionClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryInclusionClauseContext) WithClause() IWithClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithClauseContext)
}

func (s *QueryInclusionClauseContext) WithoutClause() IWithoutClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWithoutClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWithoutClauseContext)
}

func (s *QueryInclusionClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryInclusionClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryInclusionClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQueryInclusionClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QueryInclusionClause() (localctx IQueryInclusionClauseContext) {
	localctx = NewQueryInclusionClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, CqlParserRULE_queryInclusionClause)
	p.SetState(501)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__34:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(499)
			p.WithClause()
		}


	case CqlParserT__36:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(500)
			p.WithoutClause()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithClauseContext is an interface to support dynamic dispatch.
type IWithClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasedQuerySource() IAliasedQuerySourceContext
	Expression() IExpressionContext

	// IsWithClauseContext differentiates from other interfaces.
	IsWithClauseContext()
}

type WithClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithClauseContext() *WithClauseContext {
	var p = new(WithClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withClause
	return p
}

func InitEmptyWithClauseContext(p *WithClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withClause
}

func (*WithClauseContext) IsWithClauseContext() {}

func NewWithClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithClauseContext {
	var p = new(WithClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_withClause

	return p
}

func (s *WithClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithClauseContext) AliasedQuerySource() IAliasedQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *WithClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitWithClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) WithClause() (localctx IWithClauseContext) {
	localctx = NewWithClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, CqlParserRULE_withClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(503)
		p.Match(CqlParserT__34)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(504)
		p.AliasedQuerySource()
	}
	{
		p.SetState(505)
		p.Match(CqlParserT__35)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(506)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWithoutClauseContext is an interface to support dynamic dispatch.
type IWithoutClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AliasedQuerySource() IAliasedQuerySourceContext
	Expression() IExpressionContext

	// IsWithoutClauseContext differentiates from other interfaces.
	IsWithoutClauseContext()
}

type WithoutClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWithoutClauseContext() *WithoutClauseContext {
	var p = new(WithoutClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withoutClause
	return p
}

func InitEmptyWithoutClauseContext(p *WithoutClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_withoutClause
}

func (*WithoutClauseContext) IsWithoutClauseContext() {}

func NewWithoutClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WithoutClauseContext {
	var p = new(WithoutClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_withoutClause

	return p
}

func (s *WithoutClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WithoutClauseContext) AliasedQuerySource() IAliasedQuerySourceContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *WithoutClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WithoutClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithoutClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WithoutClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitWithoutClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) WithoutClause() (localctx IWithoutClauseContext) {
	localctx = NewWithoutClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, CqlParserRULE_withoutClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(508)
		p.Match(CqlParserT__36)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(509)
		p.AliasedQuerySource()
	}
	{
		p.SetState(510)
		p.Match(CqlParserT__35)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(511)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRetrieveContext is an interface to support dynamic dispatch.
type IRetrieveContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	ContextIdentifier() IContextIdentifierContext
	Terminology() ITerminologyContext
	CodePath() ICodePathContext
	CodeComparator() ICodeComparatorContext

	// IsRetrieveContext differentiates from other interfaces.
	IsRetrieveContext()
}

type RetrieveContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRetrieveContext() *RetrieveContext {
	var p = new(RetrieveContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_retrieve
	return p
}

func InitEmptyRetrieveContext(p *RetrieveContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_retrieve
}

func (*RetrieveContext) IsRetrieveContext() {}

func NewRetrieveContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RetrieveContext {
	var p = new(RetrieveContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_retrieve

	return p
}

func (s *RetrieveContext) GetParser() antlr.Parser { return s.parser }

func (s *RetrieveContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *RetrieveContext) ContextIdentifier() IContextIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IContextIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IContextIdentifierContext)
}

func (s *RetrieveContext) Terminology() ITerminologyContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITerminologyContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITerminologyContext)
}

func (s *RetrieveContext) CodePath() ICodePathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodePathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodePathContext)
}

func (s *RetrieveContext) CodeComparator() ICodeComparatorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeComparatorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeComparatorContext)
}

func (s *RetrieveContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetrieveContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RetrieveContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitRetrieve(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Retrieve() (localctx IRetrieveContext) {
	localctx = NewRetrieveContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, CqlParserRULE_retrieve)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(513)
		p.Match(CqlParserT__37)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(517)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 40, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(514)
			p.ContextIdentifier()
		}
		{
			p.SetState(515)
			p.Match(CqlParserT__38)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(519)
		p.NamedTypeSpecifier()
	}
	p.SetState(527)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__10 {
		{
			p.SetState(520)
			p.Match(CqlParserT__10)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(524)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 41, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(521)
				p.CodePath()
			}
			{
				p.SetState(522)
				p.CodeComparator()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		{
			p.SetState(526)
			p.Terminology()
		}

	}
	{
		p.SetState(529)
		p.Match(CqlParserT__39)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IContextIdentifierContext is an interface to support dynamic dispatch.
type IContextIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext

	// IsContextIdentifierContext differentiates from other interfaces.
	IsContextIdentifierContext()
}

type ContextIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyContextIdentifierContext() *ContextIdentifierContext {
	var p = new(ContextIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_contextIdentifier
	return p
}

func InitEmptyContextIdentifierContext(p *ContextIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_contextIdentifier
}

func (*ContextIdentifierContext) IsContextIdentifierContext() {}

func NewContextIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ContextIdentifierContext {
	var p = new(ContextIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_contextIdentifier

	return p
}

func (s *ContextIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ContextIdentifierContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *ContextIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ContextIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ContextIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitContextIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ContextIdentifier() (localctx IContextIdentifierContext) {
	localctx = NewContextIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, CqlParserRULE_contextIdentifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(531)
		p.QualifiedIdentifierExpression()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodePathContext is an interface to support dynamic dispatch.
type ICodePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimplePath() ISimplePathContext

	// IsCodePathContext differentiates from other interfaces.
	IsCodePathContext()
}

type CodePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodePathContext() *CodePathContext {
	var p = new(CodePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codePath
	return p
}

func InitEmptyCodePathContext(p *CodePathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codePath
}

func (*CodePathContext) IsCodePathContext() {}

func NewCodePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodePathContext {
	var p = new(CodePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codePath

	return p
}

func (s *CodePathContext) GetParser() antlr.Parser { return s.parser }

func (s *CodePathContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *CodePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodePathContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodePath(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodePath() (localctx ICodePathContext) {
	localctx = NewCodePathContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, CqlParserRULE_codePath)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(533)
		p.simplePath(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodeComparatorContext is an interface to support dynamic dispatch.
type ICodeComparatorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsCodeComparatorContext differentiates from other interfaces.
	IsCodeComparatorContext()
}

type CodeComparatorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeComparatorContext() *CodeComparatorContext {
	var p = new(CodeComparatorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeComparator
	return p
}

func InitEmptyCodeComparatorContext(p *CodeComparatorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeComparator
}

func (*CodeComparatorContext) IsCodeComparatorContext() {}

func NewCodeComparatorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeComparatorContext {
	var p = new(CodeComparatorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeComparator

	return p
}

func (s *CodeComparatorContext) GetParser() antlr.Parser { return s.parser }
func (s *CodeComparatorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeComparatorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeComparatorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeComparator(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodeComparator() (localctx ICodeComparatorContext) {
	localctx = NewCodeComparatorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, CqlParserRULE_codeComparator)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(535)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 15393162788864) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITerminologyContext is an interface to support dynamic dispatch.
type ITerminologyContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext
	Expression() IExpressionContext

	// IsTerminologyContext differentiates from other interfaces.
	IsTerminologyContext()
}

type TerminologyContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTerminologyContext() *TerminologyContext {
	var p = new(TerminologyContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_terminology
	return p
}

func InitEmptyTerminologyContext(p *TerminologyContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_terminology
}

func (*TerminologyContext) IsTerminologyContext() {}

func NewTerminologyContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TerminologyContext {
	var p = new(TerminologyContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_terminology

	return p
}

func (s *TerminologyContext) GetParser() antlr.Parser { return s.parser }

func (s *TerminologyContext) QualifiedIdentifierExpression() IQualifiedIdentifierExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedIdentifierExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedIdentifierExpressionContext)
}

func (s *TerminologyContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TerminologyContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TerminologyContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TerminologyContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTerminology(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Terminology() (localctx ITerminologyContext) {
	localctx = NewTerminologyContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, CqlParserRULE_terminology)
	p.SetState(539)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(537)
			p.QualifiedIdentifierExpression()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(538)
			p.expression(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifierContext is an interface to support dynamic dispatch.
type IQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext

	// IsQualifierContext differentiates from other interfaces.
	IsQualifierContext()
}

type QualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifierContext() *QualifierContext {
	var p = new(QualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifier
	return p
}

func InitEmptyQualifierContext(p *QualifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifier
}

func (*QualifierContext) IsQualifierContext() {}

func NewQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifierContext {
	var p = new(QualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifier

	return p
}

func (s *QualifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Qualifier() (localctx IQualifierContext) {
	localctx = NewQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, CqlParserRULE_qualifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(541)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQueryContext is an interface to support dynamic dispatch.
type IQueryContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SourceClause() ISourceClauseContext
	LetClause() ILetClauseContext
	AllQueryInclusionClause() []IQueryInclusionClauseContext
	QueryInclusionClause(i int) IQueryInclusionClauseContext
	WhereClause() IWhereClauseContext
	AggregateClause() IAggregateClauseContext
	ReturnClause() IReturnClauseContext
	SortClause() ISortClauseContext

	// IsQueryContext differentiates from other interfaces.
	IsQueryContext()
}

type QueryContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQueryContext() *QueryContext {
	var p = new(QueryContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_query
	return p
}

func InitEmptyQueryContext(p *QueryContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_query
}

func (*QueryContext) IsQueryContext() {}

func NewQueryContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QueryContext {
	var p = new(QueryContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_query

	return p
}

func (s *QueryContext) GetParser() antlr.Parser { return s.parser }

func (s *QueryContext) SourceClause() ISourceClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISourceClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISourceClauseContext)
}

func (s *QueryContext) LetClause() ILetClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetClauseContext)
}

func (s *QueryContext) AllQueryInclusionClause() []IQueryInclusionClauseContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQueryInclusionClauseContext); ok {
			len++
		}
	}

	tst := make([]IQueryInclusionClauseContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQueryInclusionClauseContext); ok {
			tst[i] = t.(IQueryInclusionClauseContext)
			i++
		}
	}

	return tst
}

func (s *QueryContext) QueryInclusionClause(i int) IQueryInclusionClauseContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryInclusionClauseContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryInclusionClauseContext)
}

func (s *QueryContext) WhereClause() IWhereClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IWhereClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IWhereClauseContext)
}

func (s *QueryContext) AggregateClause() IAggregateClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAggregateClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAggregateClauseContext)
}

func (s *QueryContext) ReturnClause() IReturnClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReturnClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReturnClauseContext)
}

func (s *QueryContext) SortClause() ISortClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortClauseContext)
}

func (s *QueryContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QueryContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQuery(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Query() (localctx IQueryContext) {
	localctx = NewQueryContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, CqlParserRULE_query)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(543)
		p.SourceClause()
	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 44, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(544)
			p.LetClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(550)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(547)
				p.QueryInclusionClause()
			}


		}
		p.SetState(552)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 45, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	p.SetState(554)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(553)
			p.WhereClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(558)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(556)
			p.AggregateClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit} else if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 47, p.GetParserRuleContext()) == 2 {
		{
			p.SetState(557)
			p.ReturnClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	p.SetState(561)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 48, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(560)
			p.SortClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISourceClauseContext is an interface to support dynamic dispatch.
type ISourceClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllAliasedQuerySource() []IAliasedQuerySourceContext
	AliasedQuerySource(i int) IAliasedQuerySourceContext

	// IsSourceClauseContext differentiates from other interfaces.
	IsSourceClauseContext()
}

type SourceClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySourceClauseContext() *SourceClauseContext {
	var p = new(SourceClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sourceClause
	return p
}

func InitEmptySourceClauseContext(p *SourceClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sourceClause
}

func (*SourceClauseContext) IsSourceClauseContext() {}

func NewSourceClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SourceClauseContext {
	var p = new(SourceClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_sourceClause

	return p
}

func (s *SourceClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SourceClauseContext) AllAliasedQuerySource() []IAliasedQuerySourceContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			len++
		}
	}

	tst := make([]IAliasedQuerySourceContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IAliasedQuerySourceContext); ok {
			tst[i] = t.(IAliasedQuerySourceContext)
			i++
		}
	}

	return tst
}

func (s *SourceClauseContext) AliasedQuerySource(i int) IAliasedQuerySourceContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IAliasedQuerySourceContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IAliasedQuerySourceContext)
}

func (s *SourceClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SourceClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SourceClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSourceClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) SourceClause() (localctx ISourceClauseContext) {
	localctx = NewSourceClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, CqlParserRULE_sourceClause)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(564)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__18 {
		{
			p.SetState(563)
			p.Match(CqlParserT__18)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(566)
		p.AliasedQuerySource()
	}
	p.SetState(571)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(567)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(568)
				p.AliasedQuerySource()
			}


		}
		p.SetState(573)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 50, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILetClauseContext is an interface to support dynamic dispatch.
type ILetClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllLetClauseItem() []ILetClauseItemContext
	LetClauseItem(i int) ILetClauseItemContext

	// IsLetClauseContext differentiates from other interfaces.
	IsLetClauseContext()
}

type LetClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetClauseContext() *LetClauseContext {
	var p = new(LetClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_letClause
	return p
}

func InitEmptyLetClauseContext(p *LetClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_letClause
}

func (*LetClauseContext) IsLetClauseContext() {}

func NewLetClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetClauseContext {
	var p = new(LetClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_letClause

	return p
}

func (s *LetClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *LetClauseContext) AllLetClauseItem() []ILetClauseItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ILetClauseItemContext); ok {
			len++
		}
	}

	tst := make([]ILetClauseItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ILetClauseItemContext); ok {
			tst[i] = t.(ILetClauseItemContext)
			i++
		}
	}

	return tst
}

func (s *LetClauseContext) LetClauseItem(i int) ILetClauseItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILetClauseItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILetClauseItemContext)
}

func (s *LetClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LetClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLetClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) LetClause() (localctx ILetClauseContext) {
	localctx = NewLetClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, CqlParserRULE_letClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(574)
		p.Match(CqlParserT__43)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(575)
		p.LetClauseItem()
	}
	p.SetState(580)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(576)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(577)
				p.LetClauseItem()
			}


		}
		p.SetState(582)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 51, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILetClauseItemContext is an interface to support dynamic dispatch.
type ILetClauseItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext

	// IsLetClauseItemContext differentiates from other interfaces.
	IsLetClauseItemContext()
}

type LetClauseItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLetClauseItemContext() *LetClauseItemContext {
	var p = new(LetClauseItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_letClauseItem
	return p
}

func InitEmptyLetClauseItemContext(p *LetClauseItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_letClauseItem
}

func (*LetClauseItemContext) IsLetClauseItemContext() {}

func NewLetClauseItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LetClauseItemContext {
	var p = new(LetClauseItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_letClauseItem

	return p
}

func (s *LetClauseItemContext) GetParser() antlr.Parser { return s.parser }

func (s *LetClauseItemContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *LetClauseItemContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *LetClauseItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LetClauseItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *LetClauseItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLetClauseItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) LetClauseItem() (localctx ILetClauseItemContext) {
	localctx = NewLetClauseItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, CqlParserRULE_letClauseItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(583)
		p.Identifier()
	}
	{
		p.SetState(584)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(585)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IWhereClauseContext is an interface to support dynamic dispatch.
type IWhereClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsWhereClauseContext differentiates from other interfaces.
	IsWhereClauseContext()
}

type WhereClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWhereClauseContext() *WhereClauseContext {
	var p = new(WhereClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_whereClause
	return p
}

func InitEmptyWhereClauseContext(p *WhereClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_whereClause
}

func (*WhereClauseContext) IsWhereClauseContext() {}

func NewWhereClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WhereClauseContext {
	var p = new(WhereClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_whereClause

	return p
}

func (s *WhereClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *WhereClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *WhereClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WhereClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *WhereClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitWhereClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) WhereClause() (localctx IWhereClauseContext) {
	localctx = NewWhereClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, CqlParserRULE_whereClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(587)
		p.Match(CqlParserT__44)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(588)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReturnClauseContext is an interface to support dynamic dispatch.
type IReturnClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Expression() IExpressionContext

	// IsReturnClauseContext differentiates from other interfaces.
	IsReturnClauseContext()
}

type ReturnClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReturnClauseContext() *ReturnClauseContext {
	var p = new(ReturnClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_returnClause
	return p
}

func InitEmptyReturnClauseContext(p *ReturnClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_returnClause
}

func (*ReturnClauseContext) IsReturnClauseContext() {}

func NewReturnClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReturnClauseContext {
	var p = new(ReturnClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_returnClause

	return p
}

func (s *ReturnClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *ReturnClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ReturnClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReturnClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReturnClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitReturnClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ReturnClause() (localctx IReturnClauseContext) {
	localctx = NewReturnClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, CqlParserRULE_returnClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(590)
		p.Match(CqlParserT__45)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(592)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 52, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(591)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__46 || _la == CqlParserT__47) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}
	{
		p.SetState(594)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IAggregateClauseContext is an interface to support dynamic dispatch.
type IAggregateClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	Expression() IExpressionContext
	StartingClause() IStartingClauseContext

	// IsAggregateClauseContext differentiates from other interfaces.
	IsAggregateClauseContext()
}

type AggregateClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAggregateClauseContext() *AggregateClauseContext {
	var p = new(AggregateClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aggregateClause
	return p
}

func InitEmptyAggregateClauseContext(p *AggregateClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_aggregateClause
}

func (*AggregateClauseContext) IsAggregateClauseContext() {}

func NewAggregateClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AggregateClauseContext {
	var p = new(AggregateClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_aggregateClause

	return p
}

func (s *AggregateClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *AggregateClauseContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *AggregateClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *AggregateClauseContext) StartingClause() IStartingClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IStartingClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IStartingClauseContext)
}

func (s *AggregateClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *AggregateClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAggregateClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) AggregateClause() (localctx IAggregateClauseContext) {
	localctx = NewAggregateClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, CqlParserRULE_aggregateClause)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(596)
		p.Match(CqlParserT__48)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(598)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__46 || _la == CqlParserT__47 {
		{
			p.SetState(597)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__46 || _la == CqlParserT__47) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}
	{
		p.SetState(600)
		p.Identifier()
	}
	p.SetState(602)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__49 {
		{
			p.SetState(601)
			p.StartingClause()
		}

	}
	{
		p.SetState(604)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(605)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IStartingClauseContext is an interface to support dynamic dispatch.
type IStartingClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SimpleLiteral() ISimpleLiteralContext
	Quantity() IQuantityContext
	Expression() IExpressionContext

	// IsStartingClauseContext differentiates from other interfaces.
	IsStartingClauseContext()
}

type StartingClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyStartingClauseContext() *StartingClauseContext {
	var p = new(StartingClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_startingClause
	return p
}

func InitEmptyStartingClauseContext(p *StartingClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_startingClause
}

func (*StartingClauseContext) IsStartingClauseContext() {}

func NewStartingClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *StartingClauseContext {
	var p = new(StartingClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_startingClause

	return p
}

func (s *StartingClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *StartingClauseContext) SimpleLiteral() ISimpleLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLiteralContext)
}

func (s *StartingClauseContext) Quantity() IQuantityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *StartingClauseContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *StartingClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartingClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *StartingClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitStartingClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) StartingClause() (localctx IStartingClauseContext) {
	localctx = NewStartingClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, CqlParserRULE_startingClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(607)
		p.Match(CqlParserT__49)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(614)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(608)
			p.SimpleLiteral()
		}


	case 2:
		{
			p.SetState(609)
			p.Quantity()
		}


	case 3:
		{
			p.SetState(610)
			p.Match(CqlParserT__30)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(611)
			p.expression(0)
		}
		{
			p.SetState(612)
			p.Match(CqlParserT__31)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISortClauseContext is an interface to support dynamic dispatch.
type ISortClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	SortDirection() ISortDirectionContext
	AllSortByItem() []ISortByItemContext
	SortByItem(i int) ISortByItemContext

	// IsSortClauseContext differentiates from other interfaces.
	IsSortClauseContext()
}

type SortClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortClauseContext() *SortClauseContext {
	var p = new(SortClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortClause
	return p
}

func InitEmptySortClauseContext(p *SortClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortClause
}

func (*SortClauseContext) IsSortClauseContext() {}

func NewSortClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortClauseContext {
	var p = new(SortClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_sortClause

	return p
}

func (s *SortClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *SortClauseContext) SortDirection() ISortDirectionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDirectionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDirectionContext)
}

func (s *SortClauseContext) AllSortByItem() []ISortByItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ISortByItemContext); ok {
			len++
		}
	}

	tst := make([]ISortByItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ISortByItemContext); ok {
			tst[i] = t.(ISortByItemContext)
			i++
		}
	}

	return tst
}

func (s *SortClauseContext) SortByItem(i int) ISortByItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortByItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortByItemContext)
}

func (s *SortClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SortClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSortClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) SortClause() (localctx ISortClauseContext) {
	localctx = NewSortClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, CqlParserRULE_sortClause)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(616)
		p.Match(CqlParserT__50)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(627)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55:
		{
			p.SetState(617)
			p.SortDirection()
		}


	case CqlParserT__51:
		{
			p.SetState(618)
			p.Match(CqlParserT__51)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(619)
			p.SortByItem()
		}
		p.SetState(624)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(620)
					p.Match(CqlParserT__14)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(621)
					p.SortByItem()
				}


			}
			p.SetState(626)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 56, p.GetParserRuleContext())
			if p.HasError() {
				goto errorExit
			}
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISortDirectionContext is an interface to support dynamic dispatch.
type ISortDirectionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSortDirectionContext differentiates from other interfaces.
	IsSortDirectionContext()
}

type SortDirectionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortDirectionContext() *SortDirectionContext {
	var p = new(SortDirectionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortDirection
	return p
}

func InitEmptySortDirectionContext(p *SortDirectionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortDirection
}

func (*SortDirectionContext) IsSortDirectionContext() {}

func NewSortDirectionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortDirectionContext {
	var p = new(SortDirectionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_sortDirection

	return p
}

func (s *SortDirectionContext) GetParser() antlr.Parser { return s.parser }
func (s *SortDirectionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortDirectionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SortDirectionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSortDirection(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) SortDirection() (localctx ISortDirectionContext) {
	localctx = NewSortDirectionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, CqlParserRULE_sortDirection)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(629)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 135107988821114880) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISortByItemContext is an interface to support dynamic dispatch.
type ISortByItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ExpressionTerm() IExpressionTermContext
	SortDirection() ISortDirectionContext

	// IsSortByItemContext differentiates from other interfaces.
	IsSortByItemContext()
}

type SortByItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySortByItemContext() *SortByItemContext {
	var p = new(SortByItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortByItem
	return p
}

func InitEmptySortByItemContext(p *SortByItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_sortByItem
}

func (*SortByItemContext) IsSortByItemContext() {}

func NewSortByItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SortByItemContext {
	var p = new(SortByItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_sortByItem

	return p
}

func (s *SortByItemContext) GetParser() antlr.Parser { return s.parser }

func (s *SortByItemContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *SortByItemContext) SortDirection() ISortDirectionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISortDirectionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISortDirectionContext)
}

func (s *SortByItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SortByItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *SortByItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSortByItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) SortByItem() (localctx ISortByItemContext) {
	localctx = NewSortByItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, CqlParserRULE_sortByItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(631)
		p.expressionTerm(0)
	}
	p.SetState(633)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 58, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(632)
			p.SortDirection()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedIdentifierContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	AllQualifier() []IQualifierContext
	Qualifier(i int) IQualifierContext

	// IsQualifiedIdentifierContext differentiates from other interfaces.
	IsQualifiedIdentifierContext()
}

type QualifiedIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierContext() *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedIdentifier
	return p
}

func InitEmptyQualifiedIdentifierContext(p *QualifiedIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedIdentifier
}

func (*QualifiedIdentifierContext) IsQualifiedIdentifierContext() {}

func NewQualifiedIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierContext {
	var p = new(QualifiedIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifiedIdentifier

	return p
}

func (s *QualifiedIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *QualifiedIdentifierContext) AllQualifier() []IQualifierContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierContext); ok {
			len++
		}
	}

	tst := make([]IQualifierContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierContext); ok {
			tst[i] = t.(IQualifierContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdentifierContext) Qualifier(i int) IQualifierContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierContext)
}

func (s *QualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifiedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifiedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QualifiedIdentifier() (localctx IQualifiedIdentifierContext) {
	localctx = NewQualifiedIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, CqlParserRULE_qualifiedIdentifier)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(640)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(635)
				p.Qualifier()
			}
			{
				p.SetState(636)
				p.Match(CqlParserT__16)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(642)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 59, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(643)
		p.Identifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedIdentifierExpressionContext is an interface to support dynamic dispatch.
type IQualifiedIdentifierExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	AllQualifierExpression() []IQualifierExpressionContext
	QualifierExpression(i int) IQualifierExpressionContext

	// IsQualifiedIdentifierExpressionContext differentiates from other interfaces.
	IsQualifiedIdentifierExpressionContext()
}

type QualifiedIdentifierExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedIdentifierExpressionContext() *QualifiedIdentifierExpressionContext {
	var p = new(QualifiedIdentifierExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedIdentifierExpression
	return p
}

func InitEmptyQualifiedIdentifierExpressionContext(p *QualifiedIdentifierExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedIdentifierExpression
}

func (*QualifiedIdentifierExpressionContext) IsQualifiedIdentifierExpressionContext() {}

func NewQualifiedIdentifierExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedIdentifierExpressionContext {
	var p = new(QualifiedIdentifierExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifiedIdentifierExpression

	return p
}

func (s *QualifiedIdentifierExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedIdentifierExpressionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *QualifiedIdentifierExpressionContext) AllQualifierExpression() []IQualifierExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQualifierExpressionContext); ok {
			len++
		}
	}

	tst := make([]IQualifierExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQualifierExpressionContext); ok {
			tst[i] = t.(IQualifierExpressionContext)
			i++
		}
	}

	return tst
}

func (s *QualifiedIdentifierExpressionContext) QualifierExpression(i int) IQualifierExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifierExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifierExpressionContext)
}

func (s *QualifiedIdentifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedIdentifierExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifiedIdentifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifiedIdentifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QualifiedIdentifierExpression() (localctx IQualifiedIdentifierExpressionContext) {
	localctx = NewQualifiedIdentifierExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, CqlParserRULE_qualifiedIdentifierExpression)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(650)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(645)
				p.QualifierExpression()
			}
			{
				p.SetState(646)
				p.Match(CqlParserT__16)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}


		}
		p.SetState(652)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 60, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}
	{
		p.SetState(653)
		p.ReferentialIdentifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifierExpressionContext is an interface to support dynamic dispatch.
type IQualifierExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext

	// IsQualifierExpressionContext differentiates from other interfaces.
	IsQualifierExpressionContext()
}

type QualifierExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifierExpressionContext() *QualifierExpressionContext {
	var p = new(QualifierExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifierExpression
	return p
}

func InitEmptyQualifierExpressionContext(p *QualifierExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifierExpression
}

func (*QualifierExpressionContext) IsQualifierExpressionContext() {}

func NewQualifierExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifierExpressionContext {
	var p = new(QualifierExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifierExpression

	return p
}

func (s *QualifierExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifierExpressionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *QualifierExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifierExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifierExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifierExpression(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QualifierExpression() (localctx IQualifierExpressionContext) {
	localctx = NewQualifierExpressionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, CqlParserRULE_qualifierExpression)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(655)
		p.ReferentialIdentifier()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimplePathContext is an interface to support dynamic dispatch.
type ISimplePathContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimplePathContext differentiates from other interfaces.
	IsSimplePathContext()
}

type SimplePathContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimplePathContext() *SimplePathContext {
	var p = new(SimplePathContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_simplePath
	return p
}

func InitEmptySimplePathContext(p *SimplePathContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_simplePath
}

func (*SimplePathContext) IsSimplePathContext() {}

func NewSimplePathContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimplePathContext {
	var p = new(SimplePathContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_simplePath

	return p
}

func (s *SimplePathContext) GetParser() antlr.Parser { return s.parser }

func (s *SimplePathContext) CopyAll(ctx *SimplePathContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimplePathContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type SimplePathIndexerContext struct {
	SimplePathContext
}

func NewSimplePathIndexerContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathIndexerContext {
	var p = new(SimplePathIndexerContext)

	InitEmptySimplePathContext(&p.SimplePathContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathIndexerContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathIndexerContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *SimplePathIndexerContext) SimpleLiteral() ISimpleLiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimpleLiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimpleLiteralContext)
}


func (s *SimplePathIndexerContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSimplePathIndexer(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimplePathQualifiedIdentifierContext struct {
	SimplePathContext
}

func NewSimplePathQualifiedIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathQualifiedIdentifierContext {
	var p = new(SimplePathQualifiedIdentifierContext)

	InitEmptySimplePathContext(&p.SimplePathContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathQualifiedIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathQualifiedIdentifierContext) SimplePath() ISimplePathContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ISimplePathContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ISimplePathContext)
}

func (s *SimplePathQualifiedIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}


func (s *SimplePathQualifiedIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSimplePathQualifiedIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimplePathReferentialIdentifierContext struct {
	SimplePathContext
}

func NewSimplePathReferentialIdentifierContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimplePathReferentialIdentifierContext {
	var p = new(SimplePathReferentialIdentifierContext)

	InitEmptySimplePathContext(&p.SimplePathContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimplePathContext))

	return p
}

func (s *SimplePathReferentialIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimplePathReferentialIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}


func (s *SimplePathReferentialIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSimplePathReferentialIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) SimplePath() (localctx ISimplePathContext) {
	return p.simplePath(0)
}

func (p *CqlParser) simplePath(_p int) (localctx ISimplePathContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewSimplePathContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx ISimplePathContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 122
	p.EnterRecursionRule(localctx, 122, CqlParserRULE_simplePath, _p)
	var _alt int

	p.EnterOuterAlt(localctx, 1)
	localctx = NewSimplePathReferentialIdentifierContext(p, localctx)
	p.SetParserRuleContext(localctx)
	_prevctx = localctx

	{
		p.SetState(658)
		p.ReferentialIdentifier()
	}

	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(670)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(668)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 61, p.GetParserRuleContext()) {
			case 1:
				localctx = NewSimplePathQualifiedIdentifierContext(p, NewSimplePathContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_simplePath)
				p.SetState(660)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(661)
					p.Match(CqlParserT__16)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(662)
					p.ReferentialIdentifier()
				}


			case 2:
				localctx = NewSimplePathIndexerContext(p, NewSimplePathContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_simplePath)
				p.SetState(663)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(664)
					p.Match(CqlParserT__37)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(665)
					p.SimpleLiteral()
				}
				{
					p.SetState(666)
					p.Match(CqlParserT__39)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(672)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 62, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ISimpleLiteralContext is an interface to support dynamic dispatch.
type ISimpleLiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsSimpleLiteralContext differentiates from other interfaces.
	IsSimpleLiteralContext()
}

type SimpleLiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySimpleLiteralContext() *SimpleLiteralContext {
	var p = new(SimpleLiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_simpleLiteral
	return p
}

func InitEmptySimpleLiteralContext(p *SimpleLiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_simpleLiteral
}

func (*SimpleLiteralContext) IsSimpleLiteralContext() {}

func NewSimpleLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SimpleLiteralContext {
	var p = new(SimpleLiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_simpleLiteral

	return p
}

func (s *SimpleLiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *SimpleLiteralContext) CopyAll(ctx *SimpleLiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *SimpleLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleLiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type SimpleNumberLiteralContext struct {
	SimpleLiteralContext
}

func NewSimpleNumberLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleNumberLiteralContext {
	var p = new(SimpleNumberLiteralContext)

	InitEmptySimpleLiteralContext(&p.SimpleLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleLiteralContext))

	return p
}

func (s *SimpleNumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleNumberLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(CqlParserNUMBER, 0)
}


func (s *SimpleNumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSimpleNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type SimpleStringLiteralContext struct {
	SimpleLiteralContext
}

func NewSimpleStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SimpleStringLiteralContext {
	var p = new(SimpleStringLiteralContext)

	InitEmptySimpleLiteralContext(&p.SimpleLiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*SimpleLiteralContext))

	return p
}

func (s *SimpleStringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SimpleStringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}


func (s *SimpleStringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSimpleStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) SimpleLiteral() (localctx ISimpleLiteralContext) {
	localctx = NewSimpleLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, CqlParserRULE_simpleLiteral)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserSTRING:
		localctx = NewSimpleStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(673)
			p.Match(CqlParserSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserNUMBER:
		localctx = NewSimpleNumberLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(674)
			p.Match(CqlParserNUMBER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionContext is an interface to support dynamic dispatch.
type IExpressionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionContext differentiates from other interfaces.
	IsExpressionContext()
}

type ExpressionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionContext() *ExpressionContext {
	var p = new(ExpressionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expression
	return p
}

func InitEmptyExpressionContext(p *ExpressionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expression
}

func (*ExpressionContext) IsExpressionContext() {}

func NewExpressionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionContext {
	var p = new(ExpressionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_expression

	return p
}

func (s *ExpressionContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionContext) CopyAll(ctx *ExpressionContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type DurationBetweenExpressionContext struct {
	ExpressionContext
}

func NewDurationBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationBetweenExpressionContext {
	var p = new(DurationBetweenExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *DurationBetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationBetweenExpressionContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DurationBetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *DurationBetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *DurationBetweenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDurationBetweenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type InFixSetExpressionContext struct {
	ExpressionContext
}

func NewInFixSetExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InFixSetExpressionContext {
	var p = new(InFixSetExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InFixSetExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InFixSetExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InFixSetExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *InFixSetExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInFixSetExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type RetrieveExpressionContext struct {
	ExpressionContext
}

func NewRetrieveExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RetrieveExpressionContext {
	var p = new(RetrieveExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *RetrieveExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RetrieveExpressionContext) Retrieve() IRetrieveContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRetrieveContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRetrieveContext)
}


func (s *RetrieveExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitRetrieveExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type TimingExpressionContext struct {
	ExpressionContext
}

func NewTimingExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimingExpressionContext {
	var p = new(TimingExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TimingExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimingExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *TimingExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TimingExpressionContext) IntervalOperatorPhrase() IIntervalOperatorPhraseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalOperatorPhraseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalOperatorPhraseContext)
}


func (s *TimingExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTimingExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type QueryExpressionContext struct {
	ExpressionContext
}

func NewQueryExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QueryExpressionContext {
	var p = new(QueryExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *QueryExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QueryExpressionContext) Query() IQueryContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQueryContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQueryContext)
}


func (s *QueryExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQueryExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type NotExpressionContext struct {
	ExpressionContext
}

func NewNotExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NotExpressionContext {
	var p = new(NotExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *NotExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NotExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *NotExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitNotExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type BooleanExpressionContext struct {
	ExpressionContext
}

func NewBooleanExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanExpressionContext {
	var p = new(BooleanExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BooleanExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *BooleanExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitBooleanExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type OrExpressionContext struct {
	ExpressionContext
}

func NewOrExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OrExpressionContext {
	var p = new(OrExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *OrExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OrExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *OrExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *OrExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitOrExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type CastExpressionContext struct {
	ExpressionContext
}

func NewCastExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CastExpressionContext {
	var p = new(CastExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *CastExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CastExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CastExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}


func (s *CastExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCastExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type AndExpressionContext struct {
	ExpressionContext
}

func NewAndExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AndExpressionContext {
	var p = new(AndExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *AndExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AndExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *AndExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *AndExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAndExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type BetweenExpressionContext struct {
	ExpressionContext
}

func NewBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BetweenExpressionContext {
	var p = new(BetweenExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *BetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BetweenExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *BetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *BetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *BetweenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitBetweenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type MembershipExpressionContext struct {
	ExpressionContext
}

func NewMembershipExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MembershipExpressionContext {
	var p = new(MembershipExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *MembershipExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MembershipExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *MembershipExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *MembershipExpressionContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *MembershipExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitMembershipExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type DifferenceBetweenExpressionContext struct {
	ExpressionContext
}

func NewDifferenceBetweenExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DifferenceBetweenExpressionContext {
	var p = new(DifferenceBetweenExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *DifferenceBetweenExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DifferenceBetweenExpressionContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DifferenceBetweenExpressionContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *DifferenceBetweenExpressionContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *DifferenceBetweenExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDifferenceBetweenExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type InequalityExpressionContext struct {
	ExpressionContext
}

func NewInequalityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InequalityExpressionContext {
	var p = new(InequalityExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *InequalityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InequalityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *InequalityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *InequalityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInequalityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type EqualityExpressionContext struct {
	ExpressionContext
}

func NewEqualityExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EqualityExpressionContext {
	var p = new(EqualityExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *EqualityExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EqualityExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *EqualityExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *EqualityExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitEqualityExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type ExistenceExpressionContext struct {
	ExpressionContext
}

func NewExistenceExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExistenceExpressionContext {
	var p = new(ExistenceExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ExistenceExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExistenceExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *ExistenceExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitExistenceExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type ImpliesExpressionContext struct {
	ExpressionContext
}

func NewImpliesExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ImpliesExpressionContext {
	var p = new(ImpliesExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *ImpliesExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ImpliesExpressionContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ImpliesExpressionContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *ImpliesExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitImpliesExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type TermExpressionContext struct {
	ExpressionContext
}

func NewTermExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TermExpressionContext {
	var p = new(TermExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TermExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermExpressionContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *TermExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTermExpression(s)

	default:
		return t.VisitChildren(s)
	}
}


type TypeExpressionContext struct {
	ExpressionContext
}

func NewTypeExpressionContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeExpressionContext {
	var p = new(TypeExpressionContext)

	InitEmptyExpressionContext(&p.ExpressionContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionContext))

	return p
}

func (s *TypeExpressionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeExpressionContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TypeExpressionContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}


func (s *TypeExpressionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTypeExpression(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) Expression() (localctx IExpressionContext) {
	return p.expression(0)
}

func (p *CqlParser) expression(_p int) (localctx IExpressionContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 126
	p.EnterRecursionRule(localctx, 126, CqlParserRULE_expression, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(708)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 65, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTermExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(678)
			p.expressionTerm(0)
		}


	case 2:
		localctx = NewRetrieveExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(679)
			p.Retrieve()
		}


	case 3:
		localctx = NewQueryExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(680)
			p.Query()
		}


	case 4:
		localctx = NewCastExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(681)
			p.Match(CqlParserT__62)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(682)
			p.expression(0)
		}
		{
			p.SetState(683)
			p.Match(CqlParserT__61)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(684)
			p.TypeSpecifier()
		}


	case 5:
		localctx = NewNotExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(686)
			p.Match(CqlParserT__57)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(687)
			p.expression(13)
		}


	case 6:
		localctx = NewExistenceExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(688)
			p.Match(CqlParserT__63)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(689)
			p.expression(12)
		}


	case 7:
		localctx = NewDurationBetweenExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		p.SetState(692)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__67 {
			{
				p.SetState(690)
				p.Match(CqlParserT__67)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(691)
				p.Match(CqlParserT__40)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(694)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(695)
			p.Match(CqlParserT__65)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(696)
			p.expressionTerm(0)
		}
		{
			p.SetState(697)
			p.Match(CqlParserT__66)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(698)
			p.expressionTerm(0)
		}


	case 8:
		localctx = NewDifferenceBetweenExpressionContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(700)
			p.Match(CqlParserT__68)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(701)
			p.Match(CqlParserT__40)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(702)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(703)
			p.Match(CqlParserT__65)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(704)
			p.expressionTerm(0)
		}
		{
			p.SetState(705)
			p.Match(CqlParserT__66)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(706)
			p.expressionTerm(0)
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(758)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(756)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 69, p.GetParserRuleContext()) {
			case 1:
				localctx = NewInequalityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(710)

				if !(p.Precpred(p.GetParserRuleContext(), 8)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 8)", ""))
					goto errorExit
				}
				{
					p.SetState(711)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 22)) & ^0x3f) == 0 && ((int64(1) << (_la - 22)) & 844424930131971) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(712)
					p.expression(9)
				}


			case 2:
				localctx = NewTimingExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(713)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(714)
					p.IntervalOperatorPhrase()
				}
				{
					p.SetState(715)
					p.expression(8)
				}


			case 3:
				localctx = NewEqualityExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(717)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(718)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 42)) & ^0x3f) == 0 && ((int64(1) << (_la - 42)) & 3221225475) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(719)
					p.expression(7)
				}


			case 4:
				localctx = NewMembershipExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(720)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(721)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CqlParserT__40 || _la == CqlParserT__73) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				p.SetState(723)
				p.GetErrorHandler().Sync(p)


				if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 66, p.GetParserRuleContext()) == 1 {
					{
						p.SetState(722)
						p.DateTimePrecisionSpecifier()
					}

					} else if p.HasError() { // JIM
						goto errorExit
				}
				{
					p.SetState(725)
					p.expression(6)
				}


			case 5:
				localctx = NewAndExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(726)

				if !(p.Precpred(p.GetParserRuleContext(), 4)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 4)", ""))
					goto errorExit
				}
				{
					p.SetState(727)
					p.Match(CqlParserT__66)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(728)
					p.expression(5)
				}


			case 6:
				localctx = NewOrExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(729)

				if !(p.Precpred(p.GetParserRuleContext(), 3)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 3)", ""))
					goto errorExit
				}
				{
					p.SetState(730)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CqlParserT__74 || _la == CqlParserT__75) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(731)
					p.expression(4)
				}


			case 7:
				localctx = NewImpliesExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(732)

				if !(p.Precpred(p.GetParserRuleContext(), 2)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 2)", ""))
					goto errorExit
				}
				{
					p.SetState(733)
					p.Match(CqlParserT__76)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(734)
					p.expression(3)
				}


			case 8:
				localctx = NewInFixSetExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(735)

				if !(p.Precpred(p.GetParserRuleContext(), 1)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 1)", ""))
					goto errorExit
				}
				{
					p.SetState(736)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 78)) & ^0x3f) == 0 && ((int64(1) << (_la - 78)) & 15) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(737)
					p.expression(2)
				}


			case 9:
				localctx = NewBooleanExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(738)

				if !(p.Precpred(p.GetParserRuleContext(), 16)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 16)", ""))
					goto errorExit
				}
				{
					p.SetState(739)
					p.Match(CqlParserT__56)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				p.SetState(741)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == CqlParserT__57 {
					{
						p.SetState(740)
						p.Match(CqlParserT__57)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(743)
					_la = p.GetTokenStream().LA(1)

					if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 4035225266123964416) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}


			case 10:
				localctx = NewTypeExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(744)

				if !(p.Precpred(p.GetParserRuleContext(), 15)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 15)", ""))
					goto errorExit
				}
				{
					p.SetState(745)
					_la = p.GetTokenStream().LA(1)

					if !(_la == CqlParserT__56 || _la == CqlParserT__61) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(746)
					p.TypeSpecifier()
				}


			case 11:
				localctx = NewBetweenExpressionContext(p, NewExpressionContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expression)
				p.SetState(747)

				if !(p.Precpred(p.GetParserRuleContext(), 11)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 11)", ""))
					goto errorExit
				}
				p.SetState(749)
				p.GetErrorHandler().Sync(p)
				if p.HasError() {
					goto errorExit
				}
				_la = p.GetTokenStream().LA(1)


				if _la == CqlParserT__64 {
					{
						p.SetState(748)
						p.Match(CqlParserT__64)
						if p.HasError() {
								// Recognition error - abort rule
								goto errorExit
						}
					}

				}
				{
					p.SetState(751)
					p.Match(CqlParserT__65)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(752)
					p.expressionTerm(0)
				}
				{
					p.SetState(753)
					p.Match(CqlParserT__66)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(754)
					p.expressionTerm(0)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(760)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 70, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateTimePrecisionContext is an interface to support dynamic dispatch.
type IDateTimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsDateTimePrecisionContext differentiates from other interfaces.
	IsDateTimePrecisionContext()
}

type DateTimePrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimePrecisionContext() *DateTimePrecisionContext {
	var p = new(DateTimePrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimePrecision
	return p
}

func InitEmptyDateTimePrecisionContext(p *DateTimePrecisionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimePrecision
}

func (*DateTimePrecisionContext) IsDateTimePrecisionContext() {}

func NewDateTimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimePrecisionContext {
	var p = new(DateTimePrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dateTimePrecision

	return p
}

func (s *DateTimePrecisionContext) GetParser() antlr.Parser { return s.parser }
func (s *DateTimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateTimePrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDateTimePrecision(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) DateTimePrecision() (localctx IDateTimePrecisionContext) {
	localctx = NewDateTimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, CqlParserRULE_dateTimePrecision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(761)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 82)) & ^0x3f) == 0 && ((int64(1) << (_la - 82)) & 255) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateTimeComponentContext is an interface to support dynamic dispatch.
type IDateTimeComponentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext

	// IsDateTimeComponentContext differentiates from other interfaces.
	IsDateTimeComponentContext()
}

type DateTimeComponentContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimeComponentContext() *DateTimeComponentContext {
	var p = new(DateTimeComponentContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimeComponent
	return p
}

func InitEmptyDateTimeComponentContext(p *DateTimeComponentContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimeComponent
}

func (*DateTimeComponentContext) IsDateTimeComponentContext() {}

func NewDateTimeComponentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimeComponentContext {
	var p = new(DateTimeComponentContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dateTimeComponent

	return p
}

func (s *DateTimeComponentContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimeComponentContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *DateTimeComponentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeComponentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateTimeComponentContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDateTimeComponent(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) DateTimeComponent() (localctx IDateTimeComponentContext) {
	localctx = NewDateTimeComponentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, CqlParserRULE_dateTimeComponent)
	p.SetState(768)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__81, CqlParserT__82, CqlParserT__83, CqlParserT__84, CqlParserT__85, CqlParserT__86, CqlParserT__87, CqlParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(763)
			p.DateTimePrecision()
		}


	case CqlParserT__89:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(764)
			p.Match(CqlParserT__89)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserT__90:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(765)
			p.Match(CqlParserT__90)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserT__91:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(766)
			p.Match(CqlParserT__91)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserT__92:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(767)
			p.Match(CqlParserT__92)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IPluralDateTimePrecisionContext is an interface to support dynamic dispatch.
type IPluralDateTimePrecisionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsPluralDateTimePrecisionContext differentiates from other interfaces.
	IsPluralDateTimePrecisionContext()
}

type PluralDateTimePrecisionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPluralDateTimePrecisionContext() *PluralDateTimePrecisionContext {
	var p = new(PluralDateTimePrecisionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pluralDateTimePrecision
	return p
}

func InitEmptyPluralDateTimePrecisionContext(p *PluralDateTimePrecisionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_pluralDateTimePrecision
}

func (*PluralDateTimePrecisionContext) IsPluralDateTimePrecisionContext() {}

func NewPluralDateTimePrecisionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PluralDateTimePrecisionContext {
	var p = new(PluralDateTimePrecisionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_pluralDateTimePrecision

	return p
}

func (s *PluralDateTimePrecisionContext) GetParser() antlr.Parser { return s.parser }
func (s *PluralDateTimePrecisionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PluralDateTimePrecisionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *PluralDateTimePrecisionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitPluralDateTimePrecision(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) PluralDateTimePrecision() (localctx IPluralDateTimePrecisionContext) {
	localctx = NewPluralDateTimePrecisionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, CqlParserRULE_pluralDateTimePrecision)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(770)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 94)) & ^0x3f) == 0 && ((int64(1) << (_la - 94)) & 255) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExpressionTermContext is an interface to support dynamic dispatch.
type IExpressionTermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExpressionTermContext differentiates from other interfaces.
	IsExpressionTermContext()
}

type ExpressionTermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExpressionTermContext() *ExpressionTermContext {
	var p = new(ExpressionTermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionTerm
	return p
}

func InitEmptyExpressionTermContext(p *ExpressionTermContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_expressionTerm
}

func (*ExpressionTermContext) IsExpressionTermContext() {}

func NewExpressionTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExpressionTermContext {
	var p = new(ExpressionTermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_expressionTerm

	return p
}

func (s *ExpressionTermContext) GetParser() antlr.Parser { return s.parser }

func (s *ExpressionTermContext) CopyAll(ctx *ExpressionTermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *ExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExpressionTermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}





type AdditionExpressionTermContext struct {
	ExpressionTermContext
}

func NewAdditionExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AdditionExpressionTermContext {
	var p = new(AdditionExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *AdditionExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AdditionExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *AdditionExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *AdditionExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAdditionExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type IndexedExpressionTermContext struct {
	ExpressionTermContext
}

func NewIndexedExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexedExpressionTermContext {
	var p = new(IndexedExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *IndexedExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexedExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *IndexedExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *IndexedExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIndexedExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type WidthExpressionTermContext struct {
	ExpressionTermContext
}

func NewWidthExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WidthExpressionTermContext {
	var p = new(WidthExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *WidthExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WidthExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *WidthExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitWidthExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type SetAggregateExpressionTermContext struct {
	ExpressionTermContext
}

func NewSetAggregateExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SetAggregateExpressionTermContext {
	var p = new(SetAggregateExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *SetAggregateExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SetAggregateExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *SetAggregateExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *SetAggregateExpressionTermContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}


func (s *SetAggregateExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSetAggregateExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type TimeUnitExpressionTermContext struct {
	ExpressionTermContext
}

func NewTimeUnitExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeUnitExpressionTermContext {
	var p = new(TimeUnitExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *TimeUnitExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeUnitExpressionTermContext) DateTimeComponent() IDateTimeComponentContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimeComponentContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimeComponentContext)
}

func (s *TimeUnitExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *TimeUnitExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTimeUnitExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type IfThenElseExpressionTermContext struct {
	ExpressionTermContext
}

func NewIfThenElseExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IfThenElseExpressionTermContext {
	var p = new(IfThenElseExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *IfThenElseExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IfThenElseExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IfThenElseExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *IfThenElseExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIfThenElseExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type TimeBoundaryExpressionTermContext struct {
	ExpressionTermContext
}

func NewTimeBoundaryExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeBoundaryExpressionTermContext {
	var p = new(TimeBoundaryExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *TimeBoundaryExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeBoundaryExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *TimeBoundaryExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTimeBoundaryExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type ElementExtractorExpressionTermContext struct {
	ExpressionTermContext
}

func NewElementExtractorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ElementExtractorExpressionTermContext {
	var p = new(ElementExtractorExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *ElementExtractorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ElementExtractorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *ElementExtractorExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitElementExtractorExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type ConversionExpressionTermContext struct {
	ExpressionTermContext
}

func NewConversionExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConversionExpressionTermContext {
	var p = new(ConversionExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *ConversionExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConversionExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ConversionExpressionTermContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ConversionExpressionTermContext) Unit() IUnitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}


func (s *ConversionExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitConversionExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type TypeExtentExpressionTermContext struct {
	ExpressionTermContext
}

func NewTypeExtentExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TypeExtentExpressionTermContext {
	var p = new(TypeExtentExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *TypeExtentExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeExtentExpressionTermContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}


func (s *TypeExtentExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTypeExtentExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type PredecessorExpressionTermContext struct {
	ExpressionTermContext
}

func NewPredecessorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PredecessorExpressionTermContext {
	var p = new(PredecessorExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *PredecessorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PredecessorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *PredecessorExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitPredecessorExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type PointExtractorExpressionTermContext struct {
	ExpressionTermContext
}

func NewPointExtractorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PointExtractorExpressionTermContext {
	var p = new(PointExtractorExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *PointExtractorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PointExtractorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *PointExtractorExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitPointExtractorExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type MultiplicationExpressionTermContext struct {
	ExpressionTermContext
}

func NewMultiplicationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MultiplicationExpressionTermContext {
	var p = new(MultiplicationExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *MultiplicationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MultiplicationExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *MultiplicationExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *MultiplicationExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitMultiplicationExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type AggregateExpressionTermContext struct {
	ExpressionTermContext
}

func NewAggregateExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *AggregateExpressionTermContext {
	var p = new(AggregateExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *AggregateExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AggregateExpressionTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *AggregateExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitAggregateExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type DurationExpressionTermContext struct {
	ExpressionTermContext
}

func NewDurationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DurationExpressionTermContext {
	var p = new(DurationExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *DurationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DurationExpressionTermContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DurationExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *DurationExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDurationExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type DifferenceExpressionTermContext struct {
	ExpressionTermContext
}

func NewDifferenceExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DifferenceExpressionTermContext {
	var p = new(DifferenceExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *DifferenceExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DifferenceExpressionTermContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *DifferenceExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *DifferenceExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDifferenceExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type CaseExpressionTermContext struct {
	ExpressionTermContext
}

func NewCaseExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CaseExpressionTermContext {
	var p = new(CaseExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *CaseExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionTermContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionTermContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionTermContext) AllCaseExpressionItem() []ICaseExpressionItemContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICaseExpressionItemContext); ok {
			len++
		}
	}

	tst := make([]ICaseExpressionItemContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICaseExpressionItemContext); ok {
			tst[i] = t.(ICaseExpressionItemContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionTermContext) CaseExpressionItem(i int) ICaseExpressionItemContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICaseExpressionItemContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICaseExpressionItemContext)
}


func (s *CaseExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCaseExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type PowerExpressionTermContext struct {
	ExpressionTermContext
}

func NewPowerExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PowerExpressionTermContext {
	var p = new(PowerExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *PowerExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PowerExpressionTermContext) AllExpressionTerm() []IExpressionTermContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionTermContext); ok {
			len++
		}
	}

	tst := make([]IExpressionTermContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionTermContext); ok {
			tst[i] = t.(IExpressionTermContext)
			i++
		}
	}

	return tst
}

func (s *PowerExpressionTermContext) ExpressionTerm(i int) IExpressionTermContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *PowerExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitPowerExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type SuccessorExpressionTermContext struct {
	ExpressionTermContext
}

func NewSuccessorExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *SuccessorExpressionTermContext {
	var p = new(SuccessorExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *SuccessorExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SuccessorExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *SuccessorExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitSuccessorExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type PolarityExpressionTermContext struct {
	ExpressionTermContext
}

func NewPolarityExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *PolarityExpressionTermContext {
	var p = new(PolarityExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *PolarityExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PolarityExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}


func (s *PolarityExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitPolarityExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type TermExpressionTermContext struct {
	ExpressionTermContext
}

func NewTermExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TermExpressionTermContext {
	var p = new(TermExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *TermExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermExpressionTermContext) Term() ITermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITermContext)
}


func (s *TermExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTermExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type InvocationExpressionTermContext struct {
	ExpressionTermContext
}

func NewInvocationExpressionTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvocationExpressionTermContext {
	var p = new(InvocationExpressionTermContext)

	InitEmptyExpressionTermContext(&p.ExpressionTermContext)
	p.parser = parser
	p.CopyAll(ctx.(*ExpressionTermContext))

	return p
}

func (s *InvocationExpressionTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationExpressionTermContext) ExpressionTerm() IExpressionTermContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionTermContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionTermContext)
}

func (s *InvocationExpressionTermContext) QualifiedInvocation() IQualifiedInvocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedInvocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedInvocationContext)
}


func (s *InvocationExpressionTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInvocationExpressionTerm(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) ExpressionTerm() (localctx IExpressionTermContext) {
	return p.expressionTerm(0)
}

func (p *CqlParser) expressionTerm(_p int) (localctx IExpressionTermContext) {
	var _parentctx antlr.ParserRuleContext = p.GetParserRuleContext()

	_parentState := p.GetState()
	localctx = NewExpressionTermContext(p, p.GetParserRuleContext(), _parentState)
	var _prevctx IExpressionTermContext = localctx
	var _ antlr.ParserRuleContext = _prevctx // TODO: To prevent unused variable warning.
	_startState := 134
	p.EnterRecursionRule(localctx, 134, CqlParserRULE_expressionTerm, _p)
	var _la int

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(850)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 77, p.GetParserRuleContext()) {
	case 1:
		localctx = NewTermExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx

		{
			p.SetState(773)
			p.Term()
		}


	case 2:
		localctx = NewConversionExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(774)
			p.Match(CqlParserT__101)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(775)
			p.expression(0)
		}
		{
			p.SetState(776)
			p.Match(CqlParserT__102)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(779)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__20, CqlParserT__23, CqlParserT__24, CqlParserT__25, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserT__154, CqlParserT__155, CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
			{
				p.SetState(777)
				p.TypeSpecifier()
			}


		case CqlParserT__81, CqlParserT__82, CqlParserT__83, CqlParserT__84, CqlParserT__85, CqlParserT__86, CqlParserT__87, CqlParserT__88, CqlParserT__93, CqlParserT__94, CqlParserT__95, CqlParserT__96, CqlParserT__97, CqlParserT__98, CqlParserT__99, CqlParserT__100, CqlParserSTRING:
			{
				p.SetState(778)
				p.Unit()
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}


	case 3:
		localctx = NewPolarityExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(781)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__103 || _la == CqlParserT__104) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(782)
			p.expressionTerm(18)
		}


	case 4:
		localctx = NewTimeBoundaryExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(783)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__105 || _la == CqlParserT__106) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(784)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(785)
			p.expressionTerm(17)
		}


	case 5:
		localctx = NewTimeUnitExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(786)
			p.DateTimeComponent()
		}
		{
			p.SetState(787)
			p.Match(CqlParserT__18)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(788)
			p.expressionTerm(16)
		}


	case 6:
		localctx = NewDurationExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(790)
			p.Match(CqlParserT__67)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(791)
			p.Match(CqlParserT__40)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(792)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(793)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(794)
			p.expressionTerm(15)
		}


	case 7:
		localctx = NewDifferenceExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(796)
			p.Match(CqlParserT__68)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(797)
			p.Match(CqlParserT__40)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(798)
			p.PluralDateTimePrecision()
		}
		{
			p.SetState(799)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(800)
			p.expressionTerm(14)
		}


	case 8:
		localctx = NewWidthExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(802)
			p.Match(CqlParserT__108)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(803)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(804)
			p.expressionTerm(13)
		}


	case 9:
		localctx = NewSuccessorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(805)
			p.Match(CqlParserT__109)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(806)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(807)
			p.expressionTerm(12)
		}


	case 10:
		localctx = NewPredecessorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(808)
			p.Match(CqlParserT__110)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(809)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(810)
			p.expressionTerm(11)
		}


	case 11:
		localctx = NewElementExtractorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(811)
			p.Match(CqlParserT__111)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(812)
			p.Match(CqlParserT__18)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(813)
			p.expressionTerm(10)
		}


	case 12:
		localctx = NewPointExtractorExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(814)
			p.Match(CqlParserT__112)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(815)
			p.Match(CqlParserT__18)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(816)
			p.expressionTerm(9)
		}


	case 13:
		localctx = NewTypeExtentExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(817)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__113 || _la == CqlParserT__114) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(818)
			p.NamedTypeSpecifier()
		}


	case 14:
		localctx = NewIfThenElseExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(819)
			p.Match(CqlParserT__121)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(820)
			p.expression(0)
		}
		{
			p.SetState(821)
			p.Match(CqlParserT__122)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(822)
			p.expression(0)
		}
		{
			p.SetState(823)
			p.Match(CqlParserT__123)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(824)
			p.expression(0)
		}


	case 15:
		localctx = NewCaseExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(826)
			p.Match(CqlParserT__124)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(828)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4758861967782021122) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1905040784319597519) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 549753872505) != 0) {
			{
				p.SetState(827)
				p.expression(0)
			}

		}
		p.SetState(831)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for ok := true; ok; ok = _la == CqlParserT__129 {
			{
				p.SetState(830)
				p.CaseExpressionItem()
			}


			p.SetState(833)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}
		{
			p.SetState(835)
			p.Match(CqlParserT__123)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(836)
			p.expression(0)
		}
		{
			p.SetState(837)
			p.Match(CqlParserT__106)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 16:
		localctx = NewAggregateExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(839)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__47 || _la == CqlParserT__125) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(840)
			p.expression(0)
		}


	case 17:
		localctx = NewSetAggregateExpressionTermContext(p, localctx)
		p.SetParserRuleContext(localctx)
		_prevctx = localctx
		{
			p.SetState(841)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__126 || _la == CqlParserT__127) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(842)
			p.expression(0)
		}
		p.SetState(848)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 76, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(843)
				p.Match(CqlParserT__128)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			p.SetState(846)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 75, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(844)
					p.DateTimePrecision()
				}


			case 2:
				{
					p.SetState(845)
					p.expression(0)
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}
	p.GetParserRuleContext().SetStop(p.GetTokenStream().LT(-1))
	p.SetState(871)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
	if p.HasError() {
		goto errorExit
	}
	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			if p.GetParseListeners() != nil {
				p.TriggerExitRuleEvent()
			}
			_prevctx = localctx
			p.SetState(869)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
				goto errorExit
			}

			switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 78, p.GetParserRuleContext()) {
			case 1:
				localctx = NewPowerExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expressionTerm)
				p.SetState(852)

				if !(p.Precpred(p.GetParserRuleContext(), 7)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 7)", ""))
					goto errorExit
				}
				{
					p.SetState(853)
					p.Match(CqlParserT__115)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(854)
					p.expressionTerm(8)
				}


			case 2:
				localctx = NewMultiplicationExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expressionTerm)
				p.SetState(855)

				if !(p.Precpred(p.GetParserRuleContext(), 6)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 6)", ""))
					goto errorExit
				}
				{
					p.SetState(856)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 117)) & ^0x3f) == 0 && ((int64(1) << (_la - 117)) & 15) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(857)
					p.expressionTerm(7)
				}


			case 3:
				localctx = NewAdditionExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expressionTerm)
				p.SetState(858)

				if !(p.Precpred(p.GetParserRuleContext(), 5)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 5)", ""))
					goto errorExit
				}
				{
					p.SetState(859)
					_la = p.GetTokenStream().LA(1)

					if !(((int64((_la - 104)) & ^0x3f) == 0 && ((int64(1) << (_la - 104)) & 131075) != 0)) {
						p.GetErrorHandler().RecoverInline(p)
					} else {
						p.GetErrorHandler().ReportMatch(p)
						p.Consume()
					}
				}
				{
					p.SetState(860)
					p.expressionTerm(6)
				}


			case 4:
				localctx = NewInvocationExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expressionTerm)
				p.SetState(861)

				if !(p.Precpred(p.GetParserRuleContext(), 21)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 21)", ""))
					goto errorExit
				}
				{
					p.SetState(862)
					p.Match(CqlParserT__16)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(863)
					p.QualifiedInvocation()
				}


			case 5:
				localctx = NewIndexedExpressionTermContext(p, NewExpressionTermContext(p, _parentctx, _parentState))
				p.PushNewRecursionContext(localctx, _startState, CqlParserRULE_expressionTerm)
				p.SetState(864)

				if !(p.Precpred(p.GetParserRuleContext(), 20)) {
					p.SetError(antlr.NewFailedPredicateException(p, "p.Precpred(p.GetParserRuleContext(), 20)", ""))
					goto errorExit
				}
				{
					p.SetState(865)
					p.Match(CqlParserT__37)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}
				{
					p.SetState(866)
					p.expression(0)
				}
				{
					p.SetState(867)
					p.Match(CqlParserT__39)
					if p.HasError() {
							// Recognition error - abort rule
							goto errorExit
					}
				}

			case antlr.ATNInvalidAltNumber:
				goto errorExit
			}

		}
		p.SetState(873)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_alt = p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 79, p.GetParserRuleContext())
		if p.HasError() {
			goto errorExit
		}
	}



	errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.UnrollRecursionContexts(_parentctx)
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICaseExpressionItemContext is an interface to support dynamic dispatch.
type ICaseExpressionItemContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsCaseExpressionItemContext differentiates from other interfaces.
	IsCaseExpressionItemContext()
}

type CaseExpressionItemContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCaseExpressionItemContext() *CaseExpressionItemContext {
	var p = new(CaseExpressionItemContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_caseExpressionItem
	return p
}

func InitEmptyCaseExpressionItemContext(p *CaseExpressionItemContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_caseExpressionItem
}

func (*CaseExpressionItemContext) IsCaseExpressionItemContext() {}

func NewCaseExpressionItemContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CaseExpressionItemContext {
	var p = new(CaseExpressionItemContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_caseExpressionItem

	return p
}

func (s *CaseExpressionItemContext) GetParser() antlr.Parser { return s.parser }

func (s *CaseExpressionItemContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *CaseExpressionItemContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *CaseExpressionItemContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CaseExpressionItemContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CaseExpressionItemContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCaseExpressionItem(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CaseExpressionItem() (localctx ICaseExpressionItemContext) {
	localctx = NewCaseExpressionItemContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, CqlParserRULE_caseExpressionItem)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(874)
		p.Match(CqlParserT__129)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(875)
		p.expression(0)
	}
	{
		p.SetState(876)
		p.Match(CqlParserT__122)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(877)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDateTimePrecisionSpecifierContext is an interface to support dynamic dispatch.
type IDateTimePrecisionSpecifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext

	// IsDateTimePrecisionSpecifierContext differentiates from other interfaces.
	IsDateTimePrecisionSpecifierContext()
}

type DateTimePrecisionSpecifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateTimePrecisionSpecifierContext() *DateTimePrecisionSpecifierContext {
	var p = new(DateTimePrecisionSpecifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimePrecisionSpecifier
	return p
}

func InitEmptyDateTimePrecisionSpecifierContext(p *DateTimePrecisionSpecifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_dateTimePrecisionSpecifier
}

func (*DateTimePrecisionSpecifierContext) IsDateTimePrecisionSpecifierContext() {}

func NewDateTimePrecisionSpecifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateTimePrecisionSpecifierContext {
	var p = new(DateTimePrecisionSpecifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_dateTimePrecisionSpecifier

	return p
}

func (s *DateTimePrecisionSpecifierContext) GetParser() antlr.Parser { return s.parser }

func (s *DateTimePrecisionSpecifierContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *DateTimePrecisionSpecifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimePrecisionSpecifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DateTimePrecisionSpecifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDateTimePrecisionSpecifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) DateTimePrecisionSpecifier() (localctx IDateTimePrecisionSpecifierContext) {
	localctx = NewDateTimePrecisionSpecifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, CqlParserRULE_dateTimePrecisionSpecifier)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(879)
		p.DateTimePrecision()
	}
	{
		p.SetState(880)
		p.Match(CqlParserT__107)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRelativeQualifierContext is an interface to support dynamic dispatch.
type IRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsRelativeQualifierContext differentiates from other interfaces.
	IsRelativeQualifierContext()
}

type RelativeQualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRelativeQualifierContext() *RelativeQualifierContext {
	var p = new(RelativeQualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relativeQualifier
	return p
}

func InitEmptyRelativeQualifierContext(p *RelativeQualifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_relativeQualifier
}

func (*RelativeQualifierContext) IsRelativeQualifierContext() {}

func NewRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RelativeQualifierContext {
	var p = new(RelativeQualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_relativeQualifier

	return p
}

func (s *RelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *RelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RelativeQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitRelativeQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) RelativeQualifier() (localctx IRelativeQualifierContext) {
	localctx = NewRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, CqlParserRULE_relativeQualifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(882)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__130 || _la == CqlParserT__131) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IOffsetRelativeQualifierContext is an interface to support dynamic dispatch.
type IOffsetRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsOffsetRelativeQualifierContext differentiates from other interfaces.
	IsOffsetRelativeQualifierContext()
}

type OffsetRelativeQualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyOffsetRelativeQualifierContext() *OffsetRelativeQualifierContext {
	var p = new(OffsetRelativeQualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_offsetRelativeQualifier
	return p
}

func InitEmptyOffsetRelativeQualifierContext(p *OffsetRelativeQualifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_offsetRelativeQualifier
}

func (*OffsetRelativeQualifierContext) IsOffsetRelativeQualifierContext() {}

func NewOffsetRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *OffsetRelativeQualifierContext {
	var p = new(OffsetRelativeQualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_offsetRelativeQualifier

	return p
}

func (s *OffsetRelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *OffsetRelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OffsetRelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *OffsetRelativeQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitOffsetRelativeQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) OffsetRelativeQualifier() (localctx IOffsetRelativeQualifierContext) {
	localctx = NewOffsetRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, CqlParserRULE_offsetRelativeQualifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__132 || _la == CqlParserT__133) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExclusiveRelativeQualifierContext is an interface to support dynamic dispatch.
type IExclusiveRelativeQualifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsExclusiveRelativeQualifierContext differentiates from other interfaces.
	IsExclusiveRelativeQualifierContext()
}

type ExclusiveRelativeQualifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExclusiveRelativeQualifierContext() *ExclusiveRelativeQualifierContext {
	var p = new(ExclusiveRelativeQualifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_exclusiveRelativeQualifier
	return p
}

func InitEmptyExclusiveRelativeQualifierContext(p *ExclusiveRelativeQualifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_exclusiveRelativeQualifier
}

func (*ExclusiveRelativeQualifierContext) IsExclusiveRelativeQualifierContext() {}

func NewExclusiveRelativeQualifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExclusiveRelativeQualifierContext {
	var p = new(ExclusiveRelativeQualifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_exclusiveRelativeQualifier

	return p
}

func (s *ExclusiveRelativeQualifierContext) GetParser() antlr.Parser { return s.parser }
func (s *ExclusiveRelativeQualifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExclusiveRelativeQualifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExclusiveRelativeQualifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitExclusiveRelativeQualifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ExclusiveRelativeQualifier() (localctx IExclusiveRelativeQualifierContext) {
	localctx = NewExclusiveRelativeQualifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, CqlParserRULE_exclusiveRelativeQualifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__134 || _la == CqlParserT__135) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuantityOffsetContext is an interface to support dynamic dispatch.
type IQuantityOffsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Quantity() IQuantityContext
	OffsetRelativeQualifier() IOffsetRelativeQualifierContext
	ExclusiveRelativeQualifier() IExclusiveRelativeQualifierContext

	// IsQuantityOffsetContext differentiates from other interfaces.
	IsQuantityOffsetContext()
}

type QuantityOffsetContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantityOffsetContext() *QuantityOffsetContext {
	var p = new(QuantityOffsetContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_quantityOffset
	return p
}

func InitEmptyQuantityOffsetContext(p *QuantityOffsetContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_quantityOffset
}

func (*QuantityOffsetContext) IsQuantityOffsetContext() {}

func NewQuantityOffsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantityOffsetContext {
	var p = new(QuantityOffsetContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_quantityOffset

	return p
}

func (s *QuantityOffsetContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantityOffsetContext) Quantity() IQuantityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *QuantityOffsetContext) OffsetRelativeQualifier() IOffsetRelativeQualifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IOffsetRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IOffsetRelativeQualifierContext)
}

func (s *QuantityOffsetContext) ExclusiveRelativeQualifier() IExclusiveRelativeQualifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExclusiveRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExclusiveRelativeQualifierContext)
}

func (s *QuantityOffsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityOffsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuantityOffsetContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQuantityOffset(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QuantityOffset() (localctx IQuantityOffsetContext) {
	localctx = NewQuantityOffsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, CqlParserRULE_quantityOffset)
	var _la int

	p.SetState(895)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserNUMBER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(888)
			p.Quantity()
		}
		p.SetState(890)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__132 || _la == CqlParserT__133 {
			{
				p.SetState(889)
				p.OffsetRelativeQualifier()
			}

		}



	case CqlParserT__134, CqlParserT__135:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(892)
			p.ExclusiveRelativeQualifier()
		}
		{
			p.SetState(893)
			p.Quantity()
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITemporalRelationshipContext is an interface to support dynamic dispatch.
type ITemporalRelationshipContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTemporalRelationshipContext differentiates from other interfaces.
	IsTemporalRelationshipContext()
}

type TemporalRelationshipContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTemporalRelationshipContext() *TemporalRelationshipContext {
	var p = new(TemporalRelationshipContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_temporalRelationship
	return p
}

func InitEmptyTemporalRelationshipContext(p *TemporalRelationshipContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_temporalRelationship
}

func (*TemporalRelationshipContext) IsTemporalRelationshipContext() {}

func NewTemporalRelationshipContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TemporalRelationshipContext {
	var p = new(TemporalRelationshipContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_temporalRelationship

	return p
}

func (s *TemporalRelationshipContext) GetParser() antlr.Parser { return s.parser }
func (s *TemporalRelationshipContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TemporalRelationshipContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TemporalRelationshipContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTemporalRelationship(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TemporalRelationship() (localctx ITemporalRelationshipContext) {
	localctx = NewTemporalRelationshipContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, CqlParserRULE_temporalRelationship)
	var _la int

	p.SetState(905)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 84, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(898)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__136 {
			{
				p.SetState(897)
				p.Match(CqlParserT__136)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(900)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__137 || _la == CqlParserT__138) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}



	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(901)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__137 || _la == CqlParserT__138) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(903)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__139 {
			{
				p.SetState(902)
				p.Match(CqlParserT__139)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}


	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalOperatorPhraseContext is an interface to support dynamic dispatch.
type IIntervalOperatorPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsIntervalOperatorPhraseContext differentiates from other interfaces.
	IsIntervalOperatorPhraseContext()
}

type IntervalOperatorPhraseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalOperatorPhraseContext() *IntervalOperatorPhraseContext {
	var p = new(IntervalOperatorPhraseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalOperatorPhrase
	return p
}

func InitEmptyIntervalOperatorPhraseContext(p *IntervalOperatorPhraseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalOperatorPhrase
}

func (*IntervalOperatorPhraseContext) IsIntervalOperatorPhraseContext() {}

func NewIntervalOperatorPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalOperatorPhraseContext {
	var p = new(IntervalOperatorPhraseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_intervalOperatorPhrase

	return p
}

func (s *IntervalOperatorPhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalOperatorPhraseContext) CopyAll(ctx *IntervalOperatorPhraseContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *IntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalOperatorPhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type WithinIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewWithinIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *WithinIntervalOperatorPhraseContext {
	var p = new(WithinIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *WithinIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WithinIntervalOperatorPhraseContext) Quantity() IQuantityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}


func (s *WithinIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitWithinIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type IncludedInIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewIncludedInIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IncludedInIntervalOperatorPhraseContext {
	var p = new(IncludedInIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *IncludedInIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludedInIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *IncludedInIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIncludedInIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type EndsIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewEndsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *EndsIntervalOperatorPhraseContext {
	var p = new(EndsIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *EndsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EndsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *EndsIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitEndsIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type ConcurrentWithIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewConcurrentWithIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConcurrentWithIntervalOperatorPhraseContext {
	var p = new(ConcurrentWithIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) RelativeQualifier() IRelativeQualifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRelativeQualifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRelativeQualifierContext)
}

func (s *ConcurrentWithIntervalOperatorPhraseContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}


func (s *ConcurrentWithIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitConcurrentWithIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type OverlapsIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewOverlapsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *OverlapsIntervalOperatorPhraseContext {
	var p = new(OverlapsIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *OverlapsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *OverlapsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *OverlapsIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitOverlapsIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type IncludesIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewIncludesIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IncludesIntervalOperatorPhraseContext {
	var p = new(IncludesIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *IncludesIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IncludesIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *IncludesIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIncludesIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type BeforeOrAfterIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewBeforeOrAfterIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BeforeOrAfterIntervalOperatorPhraseContext {
	var p = new(BeforeOrAfterIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) TemporalRelationship() ITemporalRelationshipContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITemporalRelationshipContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITemporalRelationshipContext)
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) QuantityOffset() IQuantityOffsetContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityOffsetContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityOffsetContext)
}

func (s *BeforeOrAfterIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *BeforeOrAfterIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitBeforeOrAfterIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type MeetsIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewMeetsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MeetsIntervalOperatorPhraseContext {
	var p = new(MeetsIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *MeetsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MeetsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *MeetsIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitMeetsIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}


type StartsIntervalOperatorPhraseContext struct {
	IntervalOperatorPhraseContext
}

func NewStartsIntervalOperatorPhraseContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StartsIntervalOperatorPhraseContext {
	var p = new(StartsIntervalOperatorPhraseContext)

	InitEmptyIntervalOperatorPhraseContext(&p.IntervalOperatorPhraseContext)
	p.parser = parser
	p.CopyAll(ctx.(*IntervalOperatorPhraseContext))

	return p
}

func (s *StartsIntervalOperatorPhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StartsIntervalOperatorPhraseContext) DateTimePrecisionSpecifier() IDateTimePrecisionSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionSpecifierContext)
}


func (s *StartsIntervalOperatorPhraseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitStartsIntervalOperatorPhrase(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) IntervalOperatorPhrase() (localctx IIntervalOperatorPhraseContext) {
	localctx = NewIntervalOperatorPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, CqlParserRULE_intervalOperatorPhrase)
	var _la int

	p.SetState(988)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 108, p.GetParserRuleContext()) {
	case 1:
		localctx = NewConcurrentWithIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		p.SetState(908)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0) {
			{
				p.SetState(907)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		{
			p.SetState(910)
			p.Match(CqlParserT__143)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(912)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 82)) & ^0x3f) == 0 && ((int64(1) << (_la - 82)) & 255) != 0) {
			{
				p.SetState(911)
				p.DateTimePrecision()
			}

		}
		p.SetState(916)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}

		switch p.GetTokenStream().LA(1) {
		case CqlParserT__130, CqlParserT__131:
			{
				p.SetState(914)
				p.RelativeQualifier()
			}


		case CqlParserT__61:
			{
				p.SetState(915)
				p.Match(CqlParserT__61)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}



		default:
			p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			goto errorExit
		}
		p.SetState(919)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 88, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(918)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__105 || _la == CqlParserT__106) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 2:
		localctx = NewIncludesIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		p.SetState(922)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__64 {
			{
				p.SetState(921)
				p.Match(CqlParserT__64)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(924)
			p.Match(CqlParserT__144)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(926)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 90, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(925)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(929)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 91, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(928)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__105 || _la == CqlParserT__106) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 3:
		localctx = NewIncludedInIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		p.SetState(932)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0) {
			{
				p.SetState(931)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(935)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__64 {
			{
				p.SetState(934)
				p.Match(CqlParserT__64)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(937)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__145 || _la == CqlParserT__146) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		p.SetState(939)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 94, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(938)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 4:
		localctx = NewBeforeOrAfterIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		p.SetState(942)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0) {
			{
				p.SetState(941)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(945)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 135)) & ^0x3f) == 0 && ((int64(1) << (_la - 135)) & 2147483651) != 0) {
			{
				p.SetState(944)
				p.QuantityOffset()
			}

		}
		{
			p.SetState(947)
			p.TemporalRelationship()
		}
		p.SetState(949)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 97, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(948)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}
		p.SetState(952)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 98, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(951)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__105 || _la == CqlParserT__106) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 5:
		localctx = NewWithinIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		p.SetState(955)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0) {
			{
				p.SetState(954)
				_la = p.GetTokenStream().LA(1)

				if !(((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 7) != 0)) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(958)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__64 {
			{
				p.SetState(957)
				p.Match(CqlParserT__64)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}
		{
			p.SetState(960)
			p.Match(CqlParserT__147)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(961)
			p.Quantity()
		}
		{
			p.SetState(962)
			p.Match(CqlParserT__107)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(964)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 101, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(963)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__105 || _la == CqlParserT__106) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 6:
		localctx = NewMeetsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(966)
			p.Match(CqlParserT__148)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(968)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__137 || _la == CqlParserT__138 {
			{
				p.SetState(967)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__137 || _la == CqlParserT__138) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(971)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 103, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(970)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 7:
		localctx = NewOverlapsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(973)
			p.Match(CqlParserT__149)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(975)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__137 || _la == CqlParserT__138 {
			{
				p.SetState(974)
				_la = p.GetTokenStream().LA(1)

				if !(_la == CqlParserT__137 || _la == CqlParserT__138) {
					p.GetErrorHandler().RecoverInline(p)
				} else {
					p.GetErrorHandler().ReportMatch(p)
					p.Consume()
				}
			}

		}
		p.SetState(978)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(977)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 8:
		localctx = NewStartsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(980)
			p.Match(CqlParserT__140)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(982)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 106, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(981)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}


	case 9:
		localctx = NewEndsIntervalOperatorPhraseContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(984)
			p.Match(CqlParserT__141)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(986)
		p.GetErrorHandler().Sync(p)


		if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 107, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(985)
				p.DateTimePrecisionSpecifier()
			}

			} else if p.HasError() { // JIM
				goto errorExit
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITermContext is an interface to support dynamic dispatch.
type ITermContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTermContext differentiates from other interfaces.
	IsTermContext()
}

type TermContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTermContext() *TermContext {
	var p = new(TermContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_term
	return p
}

func InitEmptyTermContext(p *TermContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_term
}

func (*TermContext) IsTermContext() {}

func NewTermContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TermContext {
	var p = new(TermContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_term

	return p
}

func (s *TermContext) GetParser() antlr.Parser { return s.parser }

func (s *TermContext) CopyAll(ctx *TermContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *TermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TermContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type ExternalConstantTermContext struct {
	TermContext
}

func NewExternalConstantTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ExternalConstantTermContext {
	var p = new(ExternalConstantTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *ExternalConstantTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalConstantTermContext) ExternalConstant() IExternalConstantContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExternalConstantContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExternalConstantContext)
}


func (s *ExternalConstantTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitExternalConstantTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type TupleSelectorTermContext struct {
	TermContext
}

func NewTupleSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TupleSelectorTermContext {
	var p = new(TupleSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *TupleSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleSelectorTermContext) TupleSelector() ITupleSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleSelectorContext)
}


func (s *TupleSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTupleSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type LiteralTermContext struct {
	TermContext
}

func NewLiteralTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LiteralTermContext {
	var p = new(LiteralTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *LiteralTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralTermContext) Literal() ILiteralContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ILiteralContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ILiteralContext)
}


func (s *LiteralTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLiteralTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type ConceptSelectorTermContext struct {
	TermContext
}

func NewConceptSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ConceptSelectorTermContext {
	var p = new(ConceptSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *ConceptSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptSelectorTermContext) ConceptSelector() IConceptSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IConceptSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IConceptSelectorContext)
}


func (s *ConceptSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitConceptSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type ParenthesizedTermContext struct {
	TermContext
}

func NewParenthesizedTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ParenthesizedTermContext {
	var p = new(ParenthesizedTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *ParenthesizedTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParenthesizedTermContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}


func (s *ParenthesizedTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitParenthesizedTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type CodeSelectorTermContext struct {
	TermContext
}

func NewCodeSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *CodeSelectorTermContext {
	var p = new(CodeSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *CodeSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSelectorTermContext) CodeSelector() ICodeSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSelectorContext)
}


func (s *CodeSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type InvocationTermContext struct {
	TermContext
}

func NewInvocationTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InvocationTermContext {
	var p = new(InvocationTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *InvocationTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationTermContext) Invocation() IInvocationContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInvocationContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInvocationContext)
}


func (s *InvocationTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInvocationTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type InstanceSelectorTermContext struct {
	TermContext
}

func NewInstanceSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *InstanceSelectorTermContext {
	var p = new(InstanceSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *InstanceSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceSelectorTermContext) InstanceSelector() IInstanceSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceSelectorContext)
}


func (s *InstanceSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInstanceSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type IntervalSelectorTermContext struct {
	TermContext
}

func NewIntervalSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IntervalSelectorTermContext {
	var p = new(IntervalSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *IntervalSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalSelectorTermContext) IntervalSelector() IIntervalSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIntervalSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIntervalSelectorContext)
}


func (s *IntervalSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIntervalSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}


type ListSelectorTermContext struct {
	TermContext
}

func NewListSelectorTermContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ListSelectorTermContext {
	var p = new(ListSelectorTermContext)

	InitEmptyTermContext(&p.TermContext)
	p.parser = parser
	p.CopyAll(ctx.(*TermContext))

	return p
}

func (s *ListSelectorTermContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListSelectorTermContext) ListSelector() IListSelectorContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IListSelectorContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IListSelectorContext)
}


func (s *ListSelectorTermContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitListSelectorTerm(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) Term() (localctx ITermContext) {
	localctx = NewTermContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, CqlParserRULE_term)
	p.SetState(1003)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 109, p.GetParserRuleContext()) {
	case 1:
		localctx = NewInvocationTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(990)
			p.Invocation()
		}


	case 2:
		localctx = NewLiteralTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(991)
			p.Literal()
		}


	case 3:
		localctx = NewExternalConstantTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(992)
			p.ExternalConstant()
		}


	case 4:
		localctx = NewIntervalSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(993)
			p.IntervalSelector()
		}


	case 5:
		localctx = NewTupleSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(994)
			p.TupleSelector()
		}


	case 6:
		localctx = NewInstanceSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(995)
			p.InstanceSelector()
		}


	case 7:
		localctx = NewListSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(996)
			p.ListSelector()
		}


	case 8:
		localctx = NewCodeSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(997)
			p.CodeSelector()
		}


	case 9:
		localctx = NewConceptSelectorTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(998)
			p.ConceptSelector()
		}


	case 10:
		localctx = NewParenthesizedTermContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(999)
			p.Match(CqlParserT__30)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1000)
			p.expression(0)
		}
		{
			p.SetState(1001)
			p.Match(CqlParserT__31)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedInvocationContext is an interface to support dynamic dispatch.
type IQualifiedInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsQualifiedInvocationContext differentiates from other interfaces.
	IsQualifiedInvocationContext()
}

type QualifiedInvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedInvocationContext() *QualifiedInvocationContext {
	var p = new(QualifiedInvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedInvocation
	return p
}

func InitEmptyQualifiedInvocationContext(p *QualifiedInvocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedInvocation
}

func (*QualifiedInvocationContext) IsQualifiedInvocationContext() {}

func NewQualifiedInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedInvocationContext {
	var p = new(QualifiedInvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifiedInvocation

	return p
}

func (s *QualifiedInvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedInvocationContext) CopyAll(ctx *QualifiedInvocationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *QualifiedInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedInvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type QualifiedFunctionInvocationContext struct {
	QualifiedInvocationContext
}

func NewQualifiedFunctionInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedFunctionInvocationContext {
	var p = new(QualifiedFunctionInvocationContext)

	InitEmptyQualifiedInvocationContext(&p.QualifiedInvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QualifiedInvocationContext))

	return p
}

func (s *QualifiedFunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedFunctionInvocationContext) QualifiedFunction() IQualifiedFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQualifiedFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQualifiedFunctionContext)
}


func (s *QualifiedFunctionInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifiedFunctionInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}


type QualifiedMemberInvocationContext struct {
	QualifiedInvocationContext
}

func NewQualifiedMemberInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QualifiedMemberInvocationContext {
	var p = new(QualifiedMemberInvocationContext)

	InitEmptyQualifiedInvocationContext(&p.QualifiedInvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*QualifiedInvocationContext))

	return p
}

func (s *QualifiedMemberInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedMemberInvocationContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}


func (s *QualifiedMemberInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifiedMemberInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) QualifiedInvocation() (localctx IQualifiedInvocationContext) {
	localctx = NewQualifiedInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, CqlParserRULE_qualifiedInvocation)
	p.SetState(1007)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 110, p.GetParserRuleContext()) {
	case 1:
		localctx = NewQualifiedMemberInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1005)
			p.ReferentialIdentifier()
		}


	case 2:
		localctx = NewQualifiedFunctionInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1006)
			p.QualifiedFunction()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQualifiedFunctionContext is an interface to support dynamic dispatch.
type IQualifiedFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext
	ParamList() IParamListContext

	// IsQualifiedFunctionContext differentiates from other interfaces.
	IsQualifiedFunctionContext()
}

type QualifiedFunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQualifiedFunctionContext() *QualifiedFunctionContext {
	var p = new(QualifiedFunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedFunction
	return p
}

func InitEmptyQualifiedFunctionContext(p *QualifiedFunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_qualifiedFunction
}

func (*QualifiedFunctionContext) IsQualifiedFunctionContext() {}

func NewQualifiedFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QualifiedFunctionContext {
	var p = new(QualifiedFunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_qualifiedFunction

	return p
}

func (s *QualifiedFunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *QualifiedFunctionContext) IdentifierOrFunctionIdentifier() IIdentifierOrFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierOrFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierOrFunctionIdentifierContext)
}

func (s *QualifiedFunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *QualifiedFunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QualifiedFunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QualifiedFunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQualifiedFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) QualifiedFunction() (localctx IQualifiedFunctionContext) {
	localctx = NewQualifiedFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, CqlParserRULE_qualifiedFunction)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1009)
		p.IdentifierOrFunctionIdentifier()
	}
	{
		p.SetState(1010)
		p.Match(CqlParserT__30)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1012)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4758861967782021122) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1905040784319597519) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 549753872505) != 0) {
		{
			p.SetState(1011)
			p.ParamList()
		}

	}
	{
		p.SetState(1014)
		p.Match(CqlParserT__31)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInvocationContext is an interface to support dynamic dispatch.
type IInvocationContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsInvocationContext differentiates from other interfaces.
	IsInvocationContext()
}

type InvocationContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInvocationContext() *InvocationContext {
	var p = new(InvocationContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_invocation
	return p
}

func InitEmptyInvocationContext(p *InvocationContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_invocation
}

func (*InvocationContext) IsInvocationContext() {}

func NewInvocationContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InvocationContext {
	var p = new(InvocationContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_invocation

	return p
}

func (s *InvocationContext) GetParser() antlr.Parser { return s.parser }

func (s *InvocationContext) CopyAll(ctx *InvocationContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *InvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InvocationContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type TotalInvocationContext struct {
	InvocationContext
}

func NewTotalInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TotalInvocationContext {
	var p = new(TotalInvocationContext)

	InitEmptyInvocationContext(&p.InvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*InvocationContext))

	return p
}

func (s *TotalInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TotalInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTotalInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}


type ThisInvocationContext struct {
	InvocationContext
}

func NewThisInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *ThisInvocationContext {
	var p = new(ThisInvocationContext)

	InitEmptyInvocationContext(&p.InvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*InvocationContext))

	return p
}

func (s *ThisInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ThisInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitThisInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}


type IndexInvocationContext struct {
	InvocationContext
}

func NewIndexInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *IndexInvocationContext {
	var p = new(IndexInvocationContext)

	InitEmptyInvocationContext(&p.InvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*InvocationContext))

	return p
}

func (s *IndexInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IndexInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIndexInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}


type FunctionInvocationContext struct {
	InvocationContext
}

func NewFunctionInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *FunctionInvocationContext {
	var p = new(FunctionInvocationContext)

	InitEmptyInvocationContext(&p.InvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*InvocationContext))

	return p
}

func (s *FunctionInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionInvocationContext) Function() IFunctionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionContext)
}


func (s *FunctionInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFunctionInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}


type MemberInvocationContext struct {
	InvocationContext
}

func NewMemberInvocationContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *MemberInvocationContext {
	var p = new(MemberInvocationContext)

	InitEmptyInvocationContext(&p.InvocationContext)
	p.parser = parser
	p.CopyAll(ctx.(*InvocationContext))

	return p
}

func (s *MemberInvocationContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MemberInvocationContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}


func (s *MemberInvocationContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitMemberInvocation(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) Invocation() (localctx IInvocationContext) {
	localctx = NewInvocationContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, CqlParserRULE_invocation)
	p.SetState(1021)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 112, p.GetParserRuleContext()) {
	case 1:
		localctx = NewMemberInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1016)
			p.ReferentialIdentifier()
		}


	case 2:
		localctx = NewFunctionInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1017)
			p.Function()
		}


	case 3:
		localctx = NewThisInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1018)
			p.Match(CqlParserT__150)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		localctx = NewIndexInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1019)
			p.Match(CqlParserT__151)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		localctx = NewTotalInvocationContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1020)
			p.Match(CqlParserT__152)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionContext is an interface to support dynamic dispatch.
type IFunctionContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	ParamList() IParamListContext

	// IsFunctionContext differentiates from other interfaces.
	IsFunctionContext()
}

type FunctionContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionContext() *FunctionContext {
	var p = new(FunctionContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_function
	return p
}

func InitEmptyFunctionContext(p *FunctionContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_function
}

func (*FunctionContext) IsFunctionContext() {}

func NewFunctionContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionContext {
	var p = new(FunctionContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_function

	return p
}

func (s *FunctionContext) GetParser() antlr.Parser { return s.parser }

func (s *FunctionContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *FunctionContext) ParamList() IParamListContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IParamListContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IParamListContext)
}

func (s *FunctionContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFunction(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Function() (localctx IFunctionContext) {
	localctx = NewFunctionContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, CqlParserRULE_function)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1023)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1024)
		p.Match(CqlParserT__30)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1026)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4758861967782021122) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1905040784319597519) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 549753872505) != 0) {
		{
			p.SetState(1025)
			p.ParamList()
		}

	}
	{
		p.SetState(1028)
		p.Match(CqlParserT__31)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IRatioContext is an interface to support dynamic dispatch.
type IRatioContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllQuantity() []IQuantityContext
	Quantity(i int) IQuantityContext

	// IsRatioContext differentiates from other interfaces.
	IsRatioContext()
}

type RatioContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyRatioContext() *RatioContext {
	var p = new(RatioContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ratio
	return p
}

func InitEmptyRatioContext(p *RatioContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_ratio
}

func (*RatioContext) IsRatioContext() {}

func NewRatioContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *RatioContext {
	var p = new(RatioContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_ratio

	return p
}

func (s *RatioContext) GetParser() antlr.Parser { return s.parser }

func (s *RatioContext) AllQuantity() []IQuantityContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IQuantityContext); ok {
			len++
		}
	}

	tst := make([]IQuantityContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IQuantityContext); ok {
			tst[i] = t.(IQuantityContext)
			i++
		}
	}

	return tst
}

func (s *RatioContext) Quantity(i int) IQuantityContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}

func (s *RatioContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *RatioContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitRatio(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Ratio() (localctx IRatioContext) {
	localctx = NewRatioContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, CqlParserRULE_ratio)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1030)
		p.Quantity()
	}
	{
		p.SetState(1031)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1032)
		p.Quantity()
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ILiteralContext is an interface to support dynamic dispatch.
type ILiteralContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsLiteralContext differentiates from other interfaces.
	IsLiteralContext()
}

type LiteralContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLiteralContext() *LiteralContext {
	var p = new(LiteralContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_literal
	return p
}

func InitEmptyLiteralContext(p *LiteralContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_literal
}

func (*LiteralContext) IsLiteralContext() {}

func NewLiteralContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LiteralContext {
	var p = new(LiteralContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_literal

	return p
}

func (s *LiteralContext) GetParser() antlr.Parser { return s.parser }

func (s *LiteralContext) CopyAll(ctx *LiteralContext) {
	s.CopyFrom(&ctx.BaseParserRuleContext)
}

func (s *LiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LiteralContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}




type TimeLiteralContext struct {
	LiteralContext
}

func NewTimeLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *TimeLiteralContext {
	var p = new(TimeLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *TimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeLiteralContext) TIME() antlr.TerminalNode {
	return s.GetToken(CqlParserTIME, 0)
}


func (s *TimeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTimeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type NullLiteralContext struct {
	LiteralContext
}

func NewNullLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NullLiteralContext {
	var p = new(NullLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *NullLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NullLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitNullLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type RatioLiteralContext struct {
	LiteralContext
}

func NewRatioLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *RatioLiteralContext {
	var p = new(RatioLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *RatioLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *RatioLiteralContext) Ratio() IRatioContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IRatioContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IRatioContext)
}


func (s *RatioLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitRatioLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type DateTimeLiteralContext struct {
	LiteralContext
}

func NewDateTimeLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateTimeLiteralContext {
	var p = new(DateTimeLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *DateTimeLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateTimeLiteralContext) DATETIME() antlr.TerminalNode {
	return s.GetToken(CqlParserDATETIME, 0)
}


func (s *DateTimeLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDateTimeLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type StringLiteralContext struct {
	LiteralContext
}

func NewStringLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *StringLiteralContext {
	var p = new(StringLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *StringLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *StringLiteralContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}


func (s *StringLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitStringLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type DateLiteralContext struct {
	LiteralContext
}

func NewDateLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *DateLiteralContext {
	var p = new(DateLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *DateLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateLiteralContext) DATE() antlr.TerminalNode {
	return s.GetToken(CqlParserDATE, 0)
}


func (s *DateLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDateLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type BooleanLiteralContext struct {
	LiteralContext
}

func NewBooleanLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *BooleanLiteralContext {
	var p = new(BooleanLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *BooleanLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BooleanLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitBooleanLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type NumberLiteralContext struct {
	LiteralContext
}

func NewNumberLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *NumberLiteralContext {
	var p = new(NumberLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *NumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *NumberLiteralContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(CqlParserNUMBER, 0)
}


func (s *NumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type LongNumberLiteralContext struct {
	LiteralContext
}

func NewLongNumberLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *LongNumberLiteralContext {
	var p = new(LongNumberLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *LongNumberLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LongNumberLiteralContext) LONGNUMBER() antlr.TerminalNode {
	return s.GetToken(CqlParserLONGNUMBER, 0)
}


func (s *LongNumberLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitLongNumberLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}


type QuantityLiteralContext struct {
	LiteralContext
}

func NewQuantityLiteralContext(parser antlr.Parser, ctx antlr.ParserRuleContext) *QuantityLiteralContext {
	var p = new(QuantityLiteralContext)

	InitEmptyLiteralContext(&p.LiteralContext)
	p.parser = parser
	p.CopyAll(ctx.(*LiteralContext))

	return p
}

func (s *QuantityLiteralContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityLiteralContext) Quantity() IQuantityContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IQuantityContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IQuantityContext)
}


func (s *QuantityLiteralContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQuantityLiteral(s)

	default:
		return t.VisitChildren(s)
	}
}



func (p *CqlParser) Literal() (localctx ILiteralContext) {
	localctx = NewLiteralContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, CqlParserRULE_literal)
	var _la int

	p.SetState(1044)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 114, p.GetParserRuleContext()) {
	case 1:
		localctx = NewBooleanLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1034)
			_la = p.GetTokenStream().LA(1)

			if !(_la == CqlParserT__59 || _la == CqlParserT__60) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}


	case 2:
		localctx = NewNullLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1035)
			p.Match(CqlParserT__58)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 3:
		localctx = NewStringLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1036)
			p.Match(CqlParserSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 4:
		localctx = NewNumberLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(1037)
			p.Match(CqlParserNUMBER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 5:
		localctx = NewLongNumberLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(1038)
			p.Match(CqlParserLONGNUMBER)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 6:
		localctx = NewDateTimeLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(1039)
			p.Match(CqlParserDATETIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 7:
		localctx = NewDateLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(1040)
			p.Match(CqlParserDATE)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 8:
		localctx = NewTimeLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(1041)
			p.Match(CqlParserTIME)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case 9:
		localctx = NewQuantityLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(1042)
			p.Quantity()
		}


	case 10:
		localctx = NewRatioLiteralContext(p, localctx)
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(1043)
			p.Ratio()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIntervalSelectorContext is an interface to support dynamic dispatch.
type IIntervalSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsIntervalSelectorContext differentiates from other interfaces.
	IsIntervalSelectorContext()
}

type IntervalSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIntervalSelectorContext() *IntervalSelectorContext {
	var p = new(IntervalSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalSelector
	return p
}

func InitEmptyIntervalSelectorContext(p *IntervalSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_intervalSelector
}

func (*IntervalSelectorContext) IsIntervalSelectorContext() {}

func NewIntervalSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IntervalSelectorContext {
	var p = new(IntervalSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_intervalSelector

	return p
}

func (s *IntervalSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *IntervalSelectorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *IntervalSelectorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *IntervalSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IntervalSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IntervalSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIntervalSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) IntervalSelector() (localctx IIntervalSelectorContext) {
	localctx = NewIntervalSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, CqlParserRULE_intervalSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1046)
		p.Match(CqlParserT__23)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1047)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__30 || _la == CqlParserT__37) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}
	{
		p.SetState(1048)
		p.expression(0)
	}
	{
		p.SetState(1049)
		p.Match(CqlParserT__14)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1050)
		p.expression(0)
	}
	{
		p.SetState(1051)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__31 || _la == CqlParserT__39) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITupleSelectorContext is an interface to support dynamic dispatch.
type ITupleSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllTupleElementSelector() []ITupleElementSelectorContext
	TupleElementSelector(i int) ITupleElementSelectorContext

	// IsTupleSelectorContext differentiates from other interfaces.
	IsTupleSelectorContext()
}

type TupleSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleSelectorContext() *TupleSelectorContext {
	var p = new(TupleSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleSelector
	return p
}

func InitEmptyTupleSelectorContext(p *TupleSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleSelector
}

func (*TupleSelectorContext) IsTupleSelectorContext() {}

func NewTupleSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleSelectorContext {
	var p = new(TupleSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tupleSelector

	return p
}

func (s *TupleSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleSelectorContext) AllTupleElementSelector() []ITupleElementSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ITupleElementSelectorContext); ok {
			len++
		}
	}

	tst := make([]ITupleElementSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ITupleElementSelectorContext); ok {
			tst[i] = t.(ITupleElementSelectorContext)
			i++
		}
	}

	return tst
}

func (s *TupleSelectorContext) TupleElementSelector(i int) ITupleElementSelectorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITupleElementSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITupleElementSelectorContext)
}

func (s *TupleSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TupleSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTupleSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TupleSelector() (localctx ITupleSelectorContext) {
	localctx = NewTupleSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, CqlParserRULE_tupleSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1054)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__24 {
		{
			p.SetState(1053)
			p.Match(CqlParserT__24)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}

	}
	{
		p.SetState(1056)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1066)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__10:
		{
			p.SetState(1057)
			p.Match(CqlParserT__10)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1058)
			p.TupleElementSelector()
		}
		p.SetState(1063)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == CqlParserT__14 {
			{
				p.SetState(1059)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1060)
				p.TupleElementSelector()
			}


			p.SetState(1065)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1068)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITupleElementSelectorContext is an interface to support dynamic dispatch.
type ITupleElementSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	Expression() IExpressionContext

	// IsTupleElementSelectorContext differentiates from other interfaces.
	IsTupleElementSelectorContext()
}

type TupleElementSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTupleElementSelectorContext() *TupleElementSelectorContext {
	var p = new(TupleElementSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleElementSelector
	return p
}

func InitEmptyTupleElementSelectorContext(p *TupleElementSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_tupleElementSelector
}

func (*TupleElementSelectorContext) IsTupleElementSelectorContext() {}

func NewTupleElementSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TupleElementSelectorContext {
	var p = new(TupleElementSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_tupleElementSelector

	return p
}

func (s *TupleElementSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *TupleElementSelectorContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *TupleElementSelectorContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *TupleElementSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TupleElementSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TupleElementSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTupleElementSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TupleElementSelector() (localctx ITupleElementSelectorContext) {
	localctx = NewTupleElementSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, CqlParserRULE_tupleElementSelector)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1070)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1071)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1072)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInstanceSelectorContext is an interface to support dynamic dispatch.
type IInstanceSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NamedTypeSpecifier() INamedTypeSpecifierContext
	AllInstanceElementSelector() []IInstanceElementSelectorContext
	InstanceElementSelector(i int) IInstanceElementSelectorContext

	// IsInstanceSelectorContext differentiates from other interfaces.
	IsInstanceSelectorContext()
}

type InstanceSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceSelectorContext() *InstanceSelectorContext {
	var p = new(InstanceSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_instanceSelector
	return p
}

func InitEmptyInstanceSelectorContext(p *InstanceSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_instanceSelector
}

func (*InstanceSelectorContext) IsInstanceSelectorContext() {}

func NewInstanceSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceSelectorContext {
	var p = new(InstanceSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_instanceSelector

	return p
}

func (s *InstanceSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceSelectorContext) NamedTypeSpecifier() INamedTypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(INamedTypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(INamedTypeSpecifierContext)
}

func (s *InstanceSelectorContext) AllInstanceElementSelector() []IInstanceElementSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IInstanceElementSelectorContext); ok {
			len++
		}
	}

	tst := make([]IInstanceElementSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IInstanceElementSelectorContext); ok {
			tst[i] = t.(IInstanceElementSelectorContext)
			i++
		}
	}

	return tst
}

func (s *InstanceSelectorContext) InstanceElementSelector(i int) IInstanceElementSelectorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IInstanceElementSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IInstanceElementSelectorContext)
}

func (s *InstanceSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InstanceSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInstanceSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) InstanceSelector() (localctx IInstanceSelectorContext) {
	localctx = NewInstanceSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, CqlParserRULE_instanceSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1074)
		p.NamedTypeSpecifier()
	}
	{
		p.SetState(1075)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1085)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__10:
		{
			p.SetState(1076)
			p.Match(CqlParserT__10)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}


	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1077)
			p.InstanceElementSelector()
		}
		p.SetState(1082)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == CqlParserT__14 {
			{
				p.SetState(1078)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1079)
				p.InstanceElementSelector()
			}


			p.SetState(1084)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}




	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}
	{
		p.SetState(1087)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IInstanceElementSelectorContext is an interface to support dynamic dispatch.
type IInstanceElementSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	Expression() IExpressionContext

	// IsInstanceElementSelectorContext differentiates from other interfaces.
	IsInstanceElementSelectorContext()
}

type InstanceElementSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyInstanceElementSelectorContext() *InstanceElementSelectorContext {
	var p = new(InstanceElementSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_instanceElementSelector
	return p
}

func InitEmptyInstanceElementSelectorContext(p *InstanceElementSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_instanceElementSelector
}

func (*InstanceElementSelectorContext) IsInstanceElementSelectorContext() {}

func NewInstanceElementSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *InstanceElementSelectorContext {
	var p = new(InstanceElementSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_instanceElementSelector

	return p
}

func (s *InstanceElementSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *InstanceElementSelectorContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *InstanceElementSelectorContext) Expression() IExpressionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *InstanceElementSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *InstanceElementSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *InstanceElementSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitInstanceElementSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) InstanceElementSelector() (localctx IInstanceElementSelectorContext) {
	localctx = NewInstanceElementSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, CqlParserRULE_instanceElementSelector)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1089)
		p.ReferentialIdentifier()
	}
	{
		p.SetState(1090)
		p.Match(CqlParserT__10)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1091)
		p.expression(0)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IListSelectorContext is an interface to support dynamic dispatch.
type IListSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext
	TypeSpecifier() ITypeSpecifierContext

	// IsListSelectorContext differentiates from other interfaces.
	IsListSelectorContext()
}

type ListSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyListSelectorContext() *ListSelectorContext {
	var p = new(ListSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listSelector
	return p
}

func InitEmptyListSelectorContext(p *ListSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_listSelector
}

func (*ListSelectorContext) IsListSelectorContext() {}

func NewListSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ListSelectorContext {
	var p = new(ListSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_listSelector

	return p
}

func (s *ListSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ListSelectorContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ListSelectorContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ListSelectorContext) TypeSpecifier() ITypeSpecifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeSpecifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeSpecifierContext)
}

func (s *ListSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ListSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ListSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitListSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ListSelector() (localctx IListSelectorContext) {
	localctx = NewListSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, CqlParserRULE_listSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(1100)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if _la == CqlParserT__20 {
		{
			p.SetState(1093)
			p.Match(CqlParserT__20)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		p.SetState(1098)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		if _la == CqlParserT__21 {
			{
				p.SetState(1094)
				p.Match(CqlParserT__21)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1095)
				p.TypeSpecifier()
			}
			{
				p.SetState(1096)
				p.Match(CqlParserT__22)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}

		}

	}
	{
		p.SetState(1102)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1111)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	if ((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -4758861967782021122) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -1905040784319597519) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 549753872505) != 0) {
		{
			p.SetState(1103)
			p.expression(0)
		}
		p.SetState(1108)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
			goto errorExit
		}
		_la = p.GetTokenStream().LA(1)


		for _la == CqlParserT__14 {
			{
				p.SetState(1104)
				p.Match(CqlParserT__14)
				if p.HasError() {
						// Recognition error - abort rule
						goto errorExit
				}
			}
			{
				p.SetState(1105)
				p.expression(0)
			}


			p.SetState(1110)
			p.GetErrorHandler().Sync(p)
			if p.HasError() {
		    	goto errorExit
		    }
			_la = p.GetTokenStream().LA(1)
		}

	}
	{
		p.SetState(1113)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IDisplayClauseContext is an interface to support dynamic dispatch.
type IDisplayClauseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode

	// IsDisplayClauseContext differentiates from other interfaces.
	IsDisplayClauseContext()
}

type DisplayClauseContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplayClauseContext() *DisplayClauseContext {
	var p = new(DisplayClauseContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_displayClause
	return p
}

func InitEmptyDisplayClauseContext(p *DisplayClauseContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_displayClause
}

func (*DisplayClauseContext) IsDisplayClauseContext() {}

func NewDisplayClauseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DisplayClauseContext {
	var p = new(DisplayClauseContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_displayClause

	return p
}

func (s *DisplayClauseContext) GetParser() antlr.Parser { return s.parser }

func (s *DisplayClauseContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *DisplayClauseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DisplayClauseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *DisplayClauseContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitDisplayClause(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) DisplayClause() (localctx IDisplayClauseContext) {
	localctx = NewDisplayClauseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, CqlParserRULE_displayClause)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1115)
		p.Match(CqlParserT__153)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1116)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ICodeSelectorContext is an interface to support dynamic dispatch.
type ICodeSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	STRING() antlr.TerminalNode
	CodesystemIdentifier() ICodesystemIdentifierContext
	DisplayClause() IDisplayClauseContext

	// IsCodeSelectorContext differentiates from other interfaces.
	IsCodeSelectorContext()
}

type CodeSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCodeSelectorContext() *CodeSelectorContext {
	var p = new(CodeSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeSelector
	return p
}

func InitEmptyCodeSelectorContext(p *CodeSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_codeSelector
}

func (*CodeSelectorContext) IsCodeSelectorContext() {}

func NewCodeSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CodeSelectorContext {
	var p = new(CodeSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_codeSelector

	return p
}

func (s *CodeSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *CodeSelectorContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *CodeSelectorContext) CodesystemIdentifier() ICodesystemIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodesystemIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodesystemIdentifierContext)
}

func (s *CodeSelectorContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *CodeSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CodeSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *CodeSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitCodeSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) CodeSelector() (localctx ICodeSelectorContext) {
	localctx = NewCodeSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 180, CqlParserRULE_codeSelector)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1118)
		p.Match(CqlParserT__154)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1119)
		p.Match(CqlParserSTRING)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1120)
		p.Match(CqlParserT__18)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1121)
		p.CodesystemIdentifier()
	}
	p.SetState(1123)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1122)
			p.DisplayClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IConceptSelectorContext is an interface to support dynamic dispatch.
type IConceptSelectorContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllCodeSelector() []ICodeSelectorContext
	CodeSelector(i int) ICodeSelectorContext
	DisplayClause() IDisplayClauseContext

	// IsConceptSelectorContext differentiates from other interfaces.
	IsConceptSelectorContext()
}

type ConceptSelectorContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyConceptSelectorContext() *ConceptSelectorContext {
	var p = new(ConceptSelectorContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_conceptSelector
	return p
}

func InitEmptyConceptSelectorContext(p *ConceptSelectorContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_conceptSelector
}

func (*ConceptSelectorContext) IsConceptSelectorContext() {}

func NewConceptSelectorContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ConceptSelectorContext {
	var p = new(ConceptSelectorContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_conceptSelector

	return p
}

func (s *ConceptSelectorContext) GetParser() antlr.Parser { return s.parser }

func (s *ConceptSelectorContext) AllCodeSelector() []ICodeSelectorContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			len++
		}
	}

	tst := make([]ICodeSelectorContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(ICodeSelectorContext); ok {
			tst[i] = t.(ICodeSelectorContext)
			i++
		}
	}

	return tst
}

func (s *ConceptSelectorContext) CodeSelector(i int) ICodeSelectorContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ICodeSelectorContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(ICodeSelectorContext)
}

func (s *ConceptSelectorContext) DisplayClause() IDisplayClauseContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDisplayClauseContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDisplayClauseContext)
}

func (s *ConceptSelectorContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ConceptSelectorContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ConceptSelectorContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitConceptSelector(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ConceptSelector() (localctx IConceptSelectorContext) {
	localctx = NewConceptSelectorContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 182, CqlParserRULE_conceptSelector)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1125)
		p.Match(CqlParserT__155)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1126)
		p.Match(CqlParserT__13)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	{
		p.SetState(1127)
		p.CodeSelector()
	}
	p.SetState(1132)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(1128)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1129)
			p.CodeSelector()
		}


		p.SetState(1134)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(1135)
		p.Match(CqlParserT__15)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1137)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 126, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1136)
			p.DisplayClause()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeywordContext is an interface to support dynamic dispatch.
type IKeywordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeywordContext differentiates from other interfaces.
	IsKeywordContext()
}

type KeywordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordContext() *KeywordContext {
	var p = new(KeywordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keyword
	return p
}

func InitEmptyKeywordContext(p *KeywordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keyword
}

func (*KeywordContext) IsKeywordContext() {}

func NewKeywordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordContext {
	var p = new(KeywordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_keyword

	return p
}

func (s *KeywordContext) GetParser() antlr.Parser { return s.parser }
func (s *KeywordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeywordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitKeyword(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Keyword() (localctx IKeywordContext) {
	localctx = NewKeywordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 184, CqlParserRULE_keyword)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1139)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -15150577076226) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -175643684002350017) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 478150271) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReservedWordContext is an interface to support dynamic dispatch.
type IReservedWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsReservedWordContext differentiates from other interfaces.
	IsReservedWordContext()
}

type ReservedWordContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReservedWordContext() *ReservedWordContext {
	var p = new(ReservedWordContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedWord
	return p
}

func InitEmptyReservedWordContext(p *ReservedWordContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_reservedWord
}

func (*ReservedWordContext) IsReservedWordContext() {}

func NewReservedWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReservedWordContext {
	var p = new(ReservedWordContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_reservedWord

	return p
}

func (s *ReservedWordContext) GetParser() antlr.Parser { return s.parser }
func (s *ReservedWordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReservedWordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReservedWordContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitReservedWord(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ReservedWord() (localctx IReservedWordContext) {
	localctx = NewReservedWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 186, CqlParserRULE_reservedWord)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1141)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -140787825319084032) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -283989560810272705) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 404594183) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IKeywordIdentifierContext is an interface to support dynamic dispatch.
type IKeywordIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsKeywordIdentifierContext differentiates from other interfaces.
	IsKeywordIdentifierContext()
}

type KeywordIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyKeywordIdentifierContext() *KeywordIdentifierContext {
	var p = new(KeywordIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keywordIdentifier
	return p
}

func InitEmptyKeywordIdentifierContext(p *KeywordIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_keywordIdentifier
}

func (*KeywordIdentifierContext) IsKeywordIdentifierContext() {}

func NewKeywordIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *KeywordIdentifierContext {
	var p = new(KeywordIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_keywordIdentifier

	return p
}

func (s *KeywordIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *KeywordIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *KeywordIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *KeywordIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitKeywordIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) KeywordIdentifier() (localctx IKeywordIdentifierContext) {
	localctx = NewKeywordIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 188, CqlParserRULE_keywordIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1143)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 140772674742007806) != 0) || ((int64((_la - 74)) & ^0x3f) == 0 && ((int64(1) << (_la - 74)) & 2161833627658158317) != 0) || ((int64((_la - 141)) & ^0x3f) == 0 && ((int64(1) << (_la - 141)) & 8979) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IObsoleteIdentifierContext is an interface to support dynamic dispatch.
type IObsoleteIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsObsoleteIdentifierContext differentiates from other interfaces.
	IsObsoleteIdentifierContext()
}

type ObsoleteIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObsoleteIdentifierContext() *ObsoleteIdentifierContext {
	var p = new(ObsoleteIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_obsoleteIdentifier
	return p
}

func InitEmptyObsoleteIdentifierContext(p *ObsoleteIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_obsoleteIdentifier
}

func (*ObsoleteIdentifierContext) IsObsoleteIdentifierContext() {}

func NewObsoleteIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ObsoleteIdentifierContext {
	var p = new(ObsoleteIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_obsoleteIdentifier

	return p
}

func (s *ObsoleteIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *ObsoleteIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ObsoleteIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ObsoleteIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitObsoleteIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ObsoleteIdentifier() (localctx IObsoleteIdentifierContext) {
	localctx = NewObsoleteIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 190, CqlParserRULE_obsoleteIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1145)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & 288687772990177284) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & 13195146167297) != 0) || ((int64((_la - 154)) & ^0x3f) == 0 && ((int64(1) << (_la - 154)) & 7) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IFunctionIdentifierContext is an interface to support dynamic dispatch.
type IFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsFunctionIdentifierContext differentiates from other interfaces.
	IsFunctionIdentifierContext()
}

type FunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFunctionIdentifierContext() *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionIdentifier
	return p
}

func InitEmptyFunctionIdentifierContext(p *FunctionIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_functionIdentifier
}

func (*FunctionIdentifierContext) IsFunctionIdentifierContext() {}

func NewFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FunctionIdentifierContext {
	var p = new(FunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_functionIdentifier

	return p
}

func (s *FunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *FunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *FunctionIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitFunctionIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) FunctionIdentifier() (localctx IFunctionIdentifierContext) {
	localctx = NewFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 192, CqlParserRULE_functionIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1147)
		_la = p.GetTokenStream().LA(1)

		if !(((int64(_la) & ^0x3f) == 0 && ((int64(1) << _la) & -15150577076226) != 0) || ((int64((_la - 64)) & ^0x3f) == 0 && ((int64(1) << (_la - 64)) & -175643684002350017) != 0) || ((int64((_la - 128)) & ^0x3f) == 0 && ((int64(1) << (_la - 128)) & 478145663) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// ITypeNameIdentifierContext is an interface to support dynamic dispatch.
type ITypeNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser
	// IsTypeNameIdentifierContext differentiates from other interfaces.
	IsTypeNameIdentifierContext()
}

type TypeNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTypeNameIdentifierContext() *TypeNameIdentifierContext {
	var p = new(TypeNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeNameIdentifier
	return p
}

func InitEmptyTypeNameIdentifierContext(p *TypeNameIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_typeNameIdentifier
}

func (*TypeNameIdentifierContext) IsTypeNameIdentifierContext() {}

func NewTypeNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TypeNameIdentifierContext {
	var p = new(TypeNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_typeNameIdentifier

	return p
}

func (s *TypeNameIdentifierContext) GetParser() antlr.Parser { return s.parser }
func (s *TypeNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TypeNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *TypeNameIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitTypeNameIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) TypeNameIdentifier() (localctx ITypeNameIdentifierContext) {
	localctx = NewTypeNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 194, CqlParserRULE_typeNameIdentifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1149)
		_la = p.GetTokenStream().LA(1)

		if !(_la == CqlParserT__89 || _la == CqlParserT__90 || _la == CqlParserT__154 || _la == CqlParserT__155) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReferentialIdentifierContext is an interface to support dynamic dispatch.
type IReferentialIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	KeywordIdentifier() IKeywordIdentifierContext

	// IsReferentialIdentifierContext differentiates from other interfaces.
	IsReferentialIdentifierContext()
}

type ReferentialIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialIdentifierContext() *ReferentialIdentifierContext {
	var p = new(ReferentialIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_referentialIdentifier
	return p
}

func InitEmptyReferentialIdentifierContext(p *ReferentialIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_referentialIdentifier
}

func (*ReferentialIdentifierContext) IsReferentialIdentifierContext() {}

func NewReferentialIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialIdentifierContext {
	var p = new(ReferentialIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_referentialIdentifier

	return p
}

func (s *ReferentialIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ReferentialIdentifierContext) KeywordIdentifier() IKeywordIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IKeywordIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IKeywordIdentifierContext)
}

func (s *ReferentialIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferentialIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitReferentialIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ReferentialIdentifier() (localctx IReferentialIdentifierContext) {
	localctx = NewReferentialIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 196, CqlParserRULE_referentialIdentifier)
	p.SetState(1153)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1151)
			p.Identifier()
		}


	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__19, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__44, CqlParserT__49, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__73, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__105, CqlParserT__106, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__118, CqlParserT__119, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__140, CqlParserT__141, CqlParserT__144, CqlParserT__148, CqlParserT__149, CqlParserT__153:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1152)
			p.KeywordIdentifier()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IReferentialOrTypeNameIdentifierContext is an interface to support dynamic dispatch.
type IReferentialOrTypeNameIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	ReferentialIdentifier() IReferentialIdentifierContext
	TypeNameIdentifier() ITypeNameIdentifierContext

	// IsReferentialOrTypeNameIdentifierContext differentiates from other interfaces.
	IsReferentialOrTypeNameIdentifierContext()
}

type ReferentialOrTypeNameIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyReferentialOrTypeNameIdentifierContext() *ReferentialOrTypeNameIdentifierContext {
	var p = new(ReferentialOrTypeNameIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_referentialOrTypeNameIdentifier
	return p
}

func InitEmptyReferentialOrTypeNameIdentifierContext(p *ReferentialOrTypeNameIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_referentialOrTypeNameIdentifier
}

func (*ReferentialOrTypeNameIdentifierContext) IsReferentialOrTypeNameIdentifierContext() {}

func NewReferentialOrTypeNameIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ReferentialOrTypeNameIdentifierContext {
	var p = new(ReferentialOrTypeNameIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_referentialOrTypeNameIdentifier

	return p
}

func (s *ReferentialOrTypeNameIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *ReferentialOrTypeNameIdentifierContext) ReferentialIdentifier() IReferentialIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IReferentialIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IReferentialIdentifierContext)
}

func (s *ReferentialOrTypeNameIdentifierContext) TypeNameIdentifier() ITypeNameIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(ITypeNameIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(ITypeNameIdentifierContext)
}

func (s *ReferentialOrTypeNameIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ReferentialOrTypeNameIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ReferentialOrTypeNameIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitReferentialOrTypeNameIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ReferentialOrTypeNameIdentifier() (localctx IReferentialOrTypeNameIdentifierContext) {
	localctx = NewReferentialOrTypeNameIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 198, CqlParserRULE_referentialOrTypeNameIdentifier)
	p.SetState(1157)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 128, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1155)
			p.ReferentialIdentifier()
		}


	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1156)
			p.TypeNameIdentifier()
		}

	case antlr.ATNInvalidAltNumber:
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifierOrFunctionIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierOrFunctionIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	FunctionIdentifier() IFunctionIdentifierContext

	// IsIdentifierOrFunctionIdentifierContext differentiates from other interfaces.
	IsIdentifierOrFunctionIdentifierContext()
}

type IdentifierOrFunctionIdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierOrFunctionIdentifierContext() *IdentifierOrFunctionIdentifierContext {
	var p = new(IdentifierOrFunctionIdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_identifierOrFunctionIdentifier
	return p
}

func InitEmptyIdentifierOrFunctionIdentifierContext(p *IdentifierOrFunctionIdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_identifierOrFunctionIdentifier
}

func (*IdentifierOrFunctionIdentifierContext) IsIdentifierOrFunctionIdentifierContext() {}

func NewIdentifierOrFunctionIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierOrFunctionIdentifierContext {
	var p = new(IdentifierOrFunctionIdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_identifierOrFunctionIdentifier

	return p
}

func (s *IdentifierOrFunctionIdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierOrFunctionIdentifierContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *IdentifierOrFunctionIdentifierContext) FunctionIdentifier() IFunctionIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IFunctionIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IFunctionIdentifierContext)
}

func (s *IdentifierOrFunctionIdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierOrFunctionIdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierOrFunctionIdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIdentifierOrFunctionIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) IdentifierOrFunctionIdentifier() (localctx IIdentifierOrFunctionIdentifierContext) {
	localctx = NewIdentifierOrFunctionIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 200, CqlParserRULE_identifierOrFunctionIdentifier)
	p.SetState(1161)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1159)
			p.Identifier()
		}


	case CqlParserT__0, CqlParserT__1, CqlParserT__2, CqlParserT__3, CqlParserT__4, CqlParserT__5, CqlParserT__6, CqlParserT__7, CqlParserT__8, CqlParserT__9, CqlParserT__11, CqlParserT__12, CqlParserT__17, CqlParserT__18, CqlParserT__19, CqlParserT__20, CqlParserT__23, CqlParserT__24, CqlParserT__26, CqlParserT__27, CqlParserT__28, CqlParserT__29, CqlParserT__34, CqlParserT__35, CqlParserT__36, CqlParserT__40, CqlParserT__43, CqlParserT__44, CqlParserT__45, CqlParserT__46, CqlParserT__47, CqlParserT__48, CqlParserT__49, CqlParserT__50, CqlParserT__51, CqlParserT__52, CqlParserT__53, CqlParserT__54, CqlParserT__55, CqlParserT__56, CqlParserT__57, CqlParserT__58, CqlParserT__59, CqlParserT__60, CqlParserT__61, CqlParserT__62, CqlParserT__63, CqlParserT__64, CqlParserT__65, CqlParserT__66, CqlParserT__67, CqlParserT__68, CqlParserT__73, CqlParserT__74, CqlParserT__75, CqlParserT__76, CqlParserT__78, CqlParserT__79, CqlParserT__80, CqlParserT__81, CqlParserT__82, CqlParserT__83, CqlParserT__84, CqlParserT__85, CqlParserT__86, CqlParserT__87, CqlParserT__88, CqlParserT__89, CqlParserT__90, CqlParserT__91, CqlParserT__92, CqlParserT__93, CqlParserT__94, CqlParserT__95, CqlParserT__96, CqlParserT__97, CqlParserT__98, CqlParserT__99, CqlParserT__100, CqlParserT__101, CqlParserT__102, CqlParserT__105, CqlParserT__106, CqlParserT__107, CqlParserT__108, CqlParserT__109, CqlParserT__110, CqlParserT__111, CqlParserT__112, CqlParserT__113, CqlParserT__114, CqlParserT__118, CqlParserT__119, CqlParserT__121, CqlParserT__122, CqlParserT__123, CqlParserT__124, CqlParserT__125, CqlParserT__126, CqlParserT__127, CqlParserT__128, CqlParserT__129, CqlParserT__130, CqlParserT__131, CqlParserT__132, CqlParserT__133, CqlParserT__137, CqlParserT__138, CqlParserT__140, CqlParserT__141, CqlParserT__142, CqlParserT__143, CqlParserT__144, CqlParserT__145, CqlParserT__146, CqlParserT__147, CqlParserT__148, CqlParserT__149, CqlParserT__153, CqlParserT__154, CqlParserT__155:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1160)
			p.FunctionIdentifier()
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IIdentifierContext is an interface to support dynamic dispatch.
type IIdentifierContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	IDENTIFIER() antlr.TerminalNode
	DELIMITEDIDENTIFIER() antlr.TerminalNode
	QUOTEDIDENTIFIER() antlr.TerminalNode

	// IsIdentifierContext differentiates from other interfaces.
	IsIdentifierContext()
}

type IdentifierContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyIdentifierContext() *IdentifierContext {
	var p = new(IdentifierContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_identifier
	return p
}

func InitEmptyIdentifierContext(p *IdentifierContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_identifier
}

func (*IdentifierContext) IsIdentifierContext() {}

func NewIdentifierContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *IdentifierContext {
	var p = new(IdentifierContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_identifier

	return p
}

func (s *IdentifierContext) GetParser() antlr.Parser { return s.parser }

func (s *IdentifierContext) IDENTIFIER() antlr.TerminalNode {
	return s.GetToken(CqlParserIDENTIFIER, 0)
}

func (s *IdentifierContext) DELIMITEDIDENTIFIER() antlr.TerminalNode {
	return s.GetToken(CqlParserDELIMITEDIDENTIFIER, 0)
}

func (s *IdentifierContext) QUOTEDIDENTIFIER() antlr.TerminalNode {
	return s.GetToken(CqlParserQUOTEDIDENTIFIER, 0)
}

func (s *IdentifierContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *IdentifierContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *IdentifierContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitIdentifier(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Identifier() (localctx IIdentifierContext) {
	localctx = NewIdentifierContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 202, CqlParserRULE_identifier)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1163)
		_la = p.GetTokenStream().LA(1)

		if !(((int64((_la - 158)) & ^0x3f) == 0 && ((int64(1) << (_la - 158)) & 97) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IExternalConstantContext is an interface to support dynamic dispatch.
type IExternalConstantContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	Identifier() IIdentifierContext
	STRING() antlr.TerminalNode

	// IsExternalConstantContext differentiates from other interfaces.
	IsExternalConstantContext()
}

type ExternalConstantContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyExternalConstantContext() *ExternalConstantContext {
	var p = new(ExternalConstantContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_externalConstant
	return p
}

func InitEmptyExternalConstantContext(p *ExternalConstantContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_externalConstant
}

func (*ExternalConstantContext) IsExternalConstantContext() {}

func NewExternalConstantContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ExternalConstantContext {
	var p = new(ExternalConstantContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_externalConstant

	return p
}

func (s *ExternalConstantContext) GetParser() antlr.Parser { return s.parser }

func (s *ExternalConstantContext) Identifier() IIdentifierContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IIdentifierContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IIdentifierContext)
}

func (s *ExternalConstantContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *ExternalConstantContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ExternalConstantContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ExternalConstantContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitExternalConstant(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ExternalConstant() (localctx IExternalConstantContext) {
	localctx = NewExternalConstantContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 204, CqlParserRULE_externalConstant)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1165)
		p.Match(CqlParserT__156)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1168)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserQUOTEDIDENTIFIER, CqlParserIDENTIFIER, CqlParserDELIMITEDIDENTIFIER:
		{
			p.SetState(1166)
			p.Identifier()
		}


	case CqlParserSTRING:
		{
			p.SetState(1167)
			p.Match(CqlParserSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IParamListContext is an interface to support dynamic dispatch.
type IParamListContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	AllExpression() []IExpressionContext
	Expression(i int) IExpressionContext

	// IsParamListContext differentiates from other interfaces.
	IsParamListContext()
}

type ParamListContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyParamListContext() *ParamListContext {
	var p = new(ParamListContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramList
	return p
}

func InitEmptyParamListContext(p *ParamListContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_paramList
}

func (*ParamListContext) IsParamListContext() {}

func NewParamListContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ParamListContext {
	var p = new(ParamListContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_paramList

	return p
}

func (s *ParamListContext) GetParser() antlr.Parser { return s.parser }

func (s *ParamListContext) AllExpression() []IExpressionContext {
	children := s.GetChildren()
	len := 0
	for _, ctx := range children {
		if _, ok := ctx.(IExpressionContext); ok {
			len++
		}
	}

	tst := make([]IExpressionContext, len)
	i := 0
	for _, ctx := range children {
		if t, ok := ctx.(IExpressionContext); ok {
			tst[i] = t.(IExpressionContext)
			i++
		}
	}

	return tst
}

func (s *ParamListContext) Expression(i int) IExpressionContext {
	var t antlr.RuleContext;
	j := 0
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IExpressionContext); ok {
			if j == i {
				t = ctx.(antlr.RuleContext);
				break
			}
			j++
		}
	}

	if t == nil {
		return nil
	}

	return t.(IExpressionContext)
}

func (s *ParamListContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ParamListContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *ParamListContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitParamList(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) ParamList() (localctx IParamListContext) {
	localctx = NewParamListContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 206, CqlParserRULE_paramList)
	var _la int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1170)
		p.expression(0)
	}
	p.SetState(1175)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}
	_la = p.GetTokenStream().LA(1)


	for _la == CqlParserT__14 {
		{
			p.SetState(1171)
			p.Match(CqlParserT__14)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}
		{
			p.SetState(1172)
			p.expression(0)
		}


		p.SetState(1177)
		p.GetErrorHandler().Sync(p)
		if p.HasError() {
	    	goto errorExit
	    }
		_la = p.GetTokenStream().LA(1)
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IQuantityContext is an interface to support dynamic dispatch.
type IQuantityContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	NUMBER() antlr.TerminalNode
	Unit() IUnitContext

	// IsQuantityContext differentiates from other interfaces.
	IsQuantityContext()
}

type QuantityContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuantityContext() *QuantityContext {
	var p = new(QuantityContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_quantity
	return p
}

func InitEmptyQuantityContext(p *QuantityContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_quantity
}

func (*QuantityContext) IsQuantityContext() {}

func NewQuantityContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QuantityContext {
	var p = new(QuantityContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_quantity

	return p
}

func (s *QuantityContext) GetParser() antlr.Parser { return s.parser }

func (s *QuantityContext) NUMBER() antlr.TerminalNode {
	return s.GetToken(CqlParserNUMBER, 0)
}

func (s *QuantityContext) Unit() IUnitContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IUnitContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IUnitContext)
}

func (s *QuantityContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QuantityContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *QuantityContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitQuantity(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Quantity() (localctx IQuantityContext) {
	localctx = NewQuantityContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 208, CqlParserRULE_quantity)
	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(1178)
		p.Match(CqlParserNUMBER)
		if p.HasError() {
				// Recognition error - abort rule
				goto errorExit
		}
	}
	p.SetState(1180)
	p.GetErrorHandler().Sync(p)


	if p.GetInterpreter().AdaptivePredict(p.BaseParser, p.GetTokenStream(), 132, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(1179)
			p.Unit()
		}

		} else if p.HasError() { // JIM
			goto errorExit
	}



errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


// IUnitContext is an interface to support dynamic dispatch.
type IUnitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// Getter signatures
	DateTimePrecision() IDateTimePrecisionContext
	PluralDateTimePrecision() IPluralDateTimePrecisionContext
	STRING() antlr.TerminalNode

	// IsUnitContext differentiates from other interfaces.
	IsUnitContext()
}

type UnitContext struct {
	antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyUnitContext() *UnitContext {
	var p = new(UnitContext)
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_unit
	return p
}

func InitEmptyUnitContext(p *UnitContext)  {
	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, nil, -1)
	p.RuleIndex = CqlParserRULE_unit
}

func (*UnitContext) IsUnitContext() {}

func NewUnitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *UnitContext {
	var p = new(UnitContext)

	antlr.InitBaseParserRuleContext(&p.BaseParserRuleContext, parent, invokingState)

	p.parser = parser
	p.RuleIndex = CqlParserRULE_unit

	return p
}

func (s *UnitContext) GetParser() antlr.Parser { return s.parser }

func (s *UnitContext) DateTimePrecision() IDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IDateTimePrecisionContext)
}

func (s *UnitContext) PluralDateTimePrecision() IPluralDateTimePrecisionContext {
	var t antlr.RuleContext;
	for _, ctx := range s.GetChildren() {
		if _, ok := ctx.(IPluralDateTimePrecisionContext); ok {
			t = ctx.(antlr.RuleContext);
			break
		}
	}

	if t == nil {
		return nil
	}

	return t.(IPluralDateTimePrecisionContext)
}

func (s *UnitContext) STRING() antlr.TerminalNode {
	return s.GetToken(CqlParserSTRING, 0)
}

func (s *UnitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *UnitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}


func (s *UnitContext) Accept(visitor antlr.ParseTreeVisitor) interface{} {
	switch t := visitor.(type) {
	case CqlVisitor:
		return t.VisitUnit(s)

	default:
		return t.VisitChildren(s)
	}
}




func (p *CqlParser) Unit() (localctx IUnitContext) {
	localctx = NewUnitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 210, CqlParserRULE_unit)
	p.SetState(1185)
	p.GetErrorHandler().Sync(p)
	if p.HasError() {
		goto errorExit
	}

	switch p.GetTokenStream().LA(1) {
	case CqlParserT__81, CqlParserT__82, CqlParserT__83, CqlParserT__84, CqlParserT__85, CqlParserT__86, CqlParserT__87, CqlParserT__88:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(1182)
			p.DateTimePrecision()
		}


	case CqlParserT__93, CqlParserT__94, CqlParserT__95, CqlParserT__96, CqlParserT__97, CqlParserT__98, CqlParserT__99, CqlParserT__100:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(1183)
			p.PluralDateTimePrecision()
		}


	case CqlParserSTRING:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(1184)
			p.Match(CqlParserSTRING)
			if p.HasError() {
					// Recognition error - abort rule
					goto errorExit
			}
		}



	default:
		p.SetError(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		goto errorExit
	}


errorExit:
	if p.HasError() {
		v := p.GetError()
		localctx.SetException(v)
		p.GetErrorHandler().ReportError(p, v)
		p.GetErrorHandler().Recover(p, v)
		p.SetError(nil)
	}
	p.ExitRule()
	return localctx
	goto errorExit // Trick to prevent compiler error if the label is not used
}


func (p *CqlParser) Sempred(localctx antlr.RuleContext, ruleIndex, predIndex int) bool {
	switch ruleIndex {
	case 61:
			var t *SimplePathContext = nil
			if localctx != nil { t = localctx.(*SimplePathContext) }
			return p.SimplePath_Sempred(t, predIndex)

	case 63:
			var t *ExpressionContext = nil
			if localctx != nil { t = localctx.(*ExpressionContext) }
			return p.Expression_Sempred(t, predIndex)

	case 67:
			var t *ExpressionTermContext = nil
			if localctx != nil { t = localctx.(*ExpressionTermContext) }
			return p.ExpressionTerm_Sempred(t, predIndex)


	default:
		panic("No predicate with index: " + fmt.Sprint(ruleIndex))
	}
}

func (p *CqlParser) SimplePath_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 0:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 1:
			return p.Precpred(p.GetParserRuleContext(), 1)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CqlParser) Expression_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 2:
			return p.Precpred(p.GetParserRuleContext(), 8)

	case 3:
			return p.Precpred(p.GetParserRuleContext(), 7)

	case 4:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 5:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 6:
			return p.Precpred(p.GetParserRuleContext(), 4)

	case 7:
			return p.Precpred(p.GetParserRuleContext(), 3)

	case 8:
			return p.Precpred(p.GetParserRuleContext(), 2)

	case 9:
			return p.Precpred(p.GetParserRuleContext(), 1)

	case 10:
			return p.Precpred(p.GetParserRuleContext(), 16)

	case 11:
			return p.Precpred(p.GetParserRuleContext(), 15)

	case 12:
			return p.Precpred(p.GetParserRuleContext(), 11)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

func (p *CqlParser) ExpressionTerm_Sempred(localctx antlr.RuleContext, predIndex int) bool {
	switch predIndex {
	case 13:
			return p.Precpred(p.GetParserRuleContext(), 7)

	case 14:
			return p.Precpred(p.GetParserRuleContext(), 6)

	case 15:
			return p.Precpred(p.GetParserRuleContext(), 5)

	case 16:
			return p.Precpred(p.GetParserRuleContext(), 21)

	case 17:
			return p.Precpred(p.GetParserRuleContext(), 20)

	default:
		panic("No predicate with index: " + fmt.Sprint(predIndex))
	}
}

